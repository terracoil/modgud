#!/usr/bin/env python3
"""
Development Tools CLI
Consolidates all development scripts into a single FreyjaCLI implementation.
"""
import glob
import os
import re
import shlex
import shutil
import subprocess
import sys
import time
import tomllib
from pathlib import Path
from subprocess import CompletedProcess
from typing import Optional, List, Union, Dict

from freyja import FreyjaCLI


# Add the project root to the Python path
# project_src =ToolUtil.get_project_name()
# PROJECT_NAME = get_project_name()
# sys.path.insert(0, str(project_src))

# Configure cache directories to use tmp/
# os.environ.setdefault('RUFF_CACHE_DIR', str(project_src / 'tmp' / '.ruff_cache'))


class FreyjaDevTools:
  """Development toolkit with build, test, and setup commands organized via Freyja's inner class pattern."""

  def __init__(self, verbose: bool = False, dry_run: bool = False) -> None:
    """Initialize with optional verbose output and dry-run mode."""
    self.verbose: bool = verbose
    self.dry_run: bool = dry_run
    self.colors: Dict[str, str] = {
      'red': '\033[0;31m',
      'green': '\033[0;32m',
      'yellow': '\033[1;33m',
      'blue': '\033[0;34m',
      'nc': '\033[0m'  # No Color
    }

    self.project_src: str = self.get_project_src()
    self.project_name: str = self.get_project_name()

    # Configure cache directories to use tmp/
    os.environ.setdefault('RUFF_CACHE_DIR', str(Path(self.project_src) / 'tmp' / '.ruff_cache'))

  @classmethod
  def get_project_src(cls) -> str:
    """Get pyproject source root"""
    with open("pyproject.toml", "rb") as f:
      proj_map = tomllib.load(f)

      # proj_root: str = ""
      try:
        proj_root: str = proj_map["tool"]["poetry"]["packages"][0]["include"]
      except Exception as x:
        print(f"Error getting proj_root; falling back to project_name: {x}")
        proj_root: str = cls.get_project_name()

    print(proj_root)
    return proj_root

  @classmethod
  def get_project_name(cls) -> str:
    """Get project name from pyproject.toml"""
    with open("pyproject.toml", "rb") as f:
      proj_map = tomllib.load(f)
      return proj_map["project"]["name"]

  def _format_command(self, command: Union[str, List[str]], shell: bool) -> Union[str, List[str]]:
    """Convert string command to list format if needed."""
    # Convert string to list if shell=False for safety
    if isinstance(command, str) and not shell:
      return shlex.split(command)
    return command

  def _display_command(self, command: Union[str, List[str]], cwd: Optional[str] = None) -> None:
    """Display command in verbose/dry-run mode."""
    cmd_display = command if isinstance(command, str) else ' '.join(shlex.quote(arg) for arg in command)
    if self.verbose or self.dry_run:
      print(f"Command: {cmd_display}")

    if self.dry_run:
      print("(DRY RUN - command not executed)")

  def _execute_subprocess(self, command: Union[str, List[str]], **kwargs) -> subprocess.CompletedProcess:
    """Execute subprocess with configured parameters."""
    # Set default cwd if not provided
    if 'cwd' not in kwargs:
      kwargs['cwd'] = self.project_src
    return subprocess.run(command, **kwargs)

  def _handle_subprocess_error(self, e: Exception, command: Union[str, List[str]],
                               capture_output: bool, check: bool) -> Union[bool, subprocess.CompletedProcess]:
    """Unified error handling for subprocess failures."""
    if isinstance(e, subprocess.CalledProcessError):
      if not capture_output:
        self._print(f"Command failed with exit code {e.returncode}", 'error')
      if check:
        raise
      return e if capture_output else False
    elif isinstance(e, subprocess.TimeoutExpired):
      if not capture_output:
        self._print(f"Command timed out after {e.timeout} seconds", 'error')
      if check:
        raise
      return subprocess.CompletedProcess(command, -1, '', 'Timeout') if capture_output else False
    elif isinstance(e, FileNotFoundError):
      cmd_name = command[0] if isinstance(command, list) and command else str(command).split()[0]
      if not capture_output:
        self._print(f"Command '{cmd_name}' not found - is it installed and in PATH?", 'error')
      return subprocess.CompletedProcess(command, -1, '', f"Command not found: {cmd_name}") if capture_output else False
    elif isinstance(e, OSError):
      if not capture_output:
        self._print(f"OS error running command: {e}", 'error')
      return subprocess.CompletedProcess(command, -1, '', str(e)) if capture_output else False
    else:
      raise  # Re-raise unexpected exceptions

  def _run_claude_prompt(self, prompt, retry_count=2, timeout=60, timeout_increment=60):
    claude_result:CompletedProcess|None = None
    last_error:str|None = None

    # Build Claude command
    claude_cmd = ['poetry', 'run', 'claude', '-p', prompt]

    for attempt in range(retry_count + 1):
      # Calculate timeout for this attempt
      current_timeout = timeout + (attempt * timeout_increment)

      if attempt > 0:
        self._print(f"üîÑ Retrying... (attempt {attempt + 1}/{retry_count + 1})", 'warning')

      self._print(f"‚è≥ Calling Claude API (attempt {attempt + 1}/{retry_count + 1}, timeout: {current_timeout}s)...",
                  'info')

      # Run with detailed timing and progress monitoring
      api_start = time.time()
      try:
        claude_result = self._run_command(
          claude_cmd,
          capture_output=True,
          timeout=current_timeout
        )
        api_elapsed = time.time() - api_start
        self._print(f"Claude API call (attempt {attempt + 1}) after {api_elapsed:.2f}s")

        # Check if command succeeded
        if claude_result and claude_result.returncode == 0:
          break
        else:
          api_elapsed = time.time() - api_start
          error_msg = claude_result.stderr if claude_result else "Command failed"
          self._print(f"‚ùå Claude API call failed after {api_elapsed:.2f}s: {error_msg}", 'error')
          last_error = f"Claude API failed: {error_msg}"
          continue

      except subprocess.TimeoutExpired as e:
        api_elapsed = time.time() - api_start
        self._print(f"‚è∞ Timeout after {api_elapsed:.2f}s (limit was {current_timeout}s)", 'error')
        last_error = f"Claude API timed out after {api_elapsed:.2f}s"
        continue

    if claude_result:
      commit_message = claude_result.stdout
    else:
      raise RuntimeError(f"Error running claude command: {claude_cmd}: {last_error}")

    return commit_message

  def _run_command(
      self,
      command: Union[str, List[str]],
      description: str = "",
      shell: bool = False,
      capture_output: bool = False,
      check: bool = False,
      timeout: Optional[int] = None,
      cwd = None,
      env = None
  ) -> Union[bool, subprocess.CompletedProcess]:
    """Execute a command with unified error handling and logging.

    Returns bool for compatibility, or CompletedProcess when capture_output=True."""
    if description:
      print(f"{self.colors['blue']}{description}{self.colors['nc']}")

    # Format command
    command = self._format_command(command, shell)

    # Display command for verbose/dry-run
    self._display_command(command)

    # Track result value for single return point
    result_value = None

    if self.dry_run:
      # Set mock result for dry-run
      result_value = subprocess.CompletedProcess(command, 0, '', '') if capture_output else True
    else:
      try:
        result = self._execute_subprocess(
          command,
          shell=shell,
          check=check,
          capture_output=capture_output,
          text=capture_output,  # Use text mode when capturing
          timeout=timeout,
          cwd = cwd,
          env = env
        )
        result_value = result if capture_output else (result.returncode == 0)
      except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        result_value = self._handle_subprocess_error(e, command, capture_output, check)

    return result_value

  def _print(self, message: str, msg_type: str = 'info') -> None:
    """Print formatted message based on type."""
    icons = {'success': '‚úÖ', 'error': '‚ùå', 'info': '‚ÑπÔ∏è', 'warning': '‚ö†Ô∏è'}
    colors = {'success': 'green', 'error': 'red', 'info': 'blue', 'warning': 'yellow'}

    color = self.colors.get(colors.get(msg_type, 'blue'), self.colors['blue'])
    icon = icons.get(msg_type, '‚ÑπÔ∏è')
    print(f"{color}{icon} {message}{self.colors['nc']}")

  class Setup:
    """Development environment and self-installation setup operations."""

    def __init__(self, parent) -> None:
      """Initialize with parent FreyjaDevTools instance."""
      self.parent: 'FreyjaDevTools' = parent

    def env(self) -> None:
      """Set up the development environment with dependencies and pre-commit hooks."""
      parent = self.parent
      print(
        f"{parent.colors['blue']}üöÄ Setting up development environment for {parent.project_name}...{parent.colors['nc']}")

      # Install dependencies
      success = parent._run_command("poetry install --with dev", "üì¶ Installing dependencies with Poetry...")
      if success:
        # Install pre-commit hooks
        success = parent._run_command("poetry run pre-commit install", "ü™ù Installing pre-commit hooks...")
        if success:
          # Verify Python version
          parent._run_command("poetry run python --version", "üêç Python version:", cwd=parent.project_src)
          parent._print("Development environment setup complete!", 'success')
          print()
          print("Available commands:")
          parent._run_command("poetry run bin/devtools")
        else:
          parent._print("Failed to install pre-commit hooks", 'error')
      else:
        parent._print("Failed to install dependencies", 'error')

    def self(self, force: bool = False) -> None:
      """Compile and install the latest version from dist/, optionally forcing reinstallation."""
      parent = self.parent
      parent._print(f"üîß Building and installing latest {parent.project_name} version...", 'info')

      # First, build the package
      parent._print("Building package first...", 'info')
      success = parent._run_command("poetry build", "üî® Building package...")

      if success:
        # Find the latest wheel file
        dist_dir = Path(parent.project_src) / "dist"
        if dist_dir.exists():
          wheel_files = list(dist_dir.glob("*.whl"))
          if wheel_files:
            # Get the latest wheel file (by modification time)
            latest_wheel = max(wheel_files, key=lambda p: p.stat().st_mtime)
            parent._print(f"Installing wheel: {latest_wheel.name}", 'info')

            # Install the wheel
            install_cmd = f"pip install {latest_wheel}"
            if force:
              install_cmd += " --force-reinstall"

            success = parent._run_command(install_cmd, f"üì¶ Installing {latest_wheel.name}...")
            if success:
              # Verify installation
              parent._run_command(
                f"python -c 'import {parent.project_name}; print(f\"{parent.project_name.capitalize()} version: {{{parent.project_name}.__version__ if hasattr({parent.project_name}, \"__version__\") else \"unknown\"}}\"); print(f\"{parent.project_name.capitalize()} location: {{{parent.project_name}.__file__}}\")'",
                "üîç Verifying installation:"
              )
              parent._print("Self-installation complete!", 'success')
              parent._print(f"You can now use '{parent.project_name}' from anywhere on your system", 'info')
            else:
              parent._print("Installation failed!", 'error')
          else:
            parent._print("No wheel files found in dist/. Build may have failed.", 'error')
        else:
          parent._print("dist/ directory not found. Run build first.", 'error')
      else:
        parent._print("Build failed!", 'error')

  class Build:
    """Build and compilation operations."""

    def __init__(self, parent, parallel: bool = True) -> None:
      """Initialize with parent and optional parallel execution."""
      self.parent: 'FreyjaDevTools' = parent
      self.parallel: bool = parallel

    def _remove_path(self, path_obj: Path) -> bool:
      """Remove a single file or directory with error handling."""
      parent = self.parent
      path_str = str(path_obj)

      try:
        if path_obj.is_dir():
          if not parent.dry_run:
            shutil.rmtree(path_obj)
          if parent.verbose or parent.dry_run:
            print(f"Removed directory: {path_str}")
        elif path_obj.is_file():
          if not parent.dry_run:
            path_obj.unlink()
          if parent.verbose or parent.dry_run:
            print(f"Removed file: {path_str}")
        return True
      except PermissionError:
        parent._print(f"Permission denied removing {path_str} - try running with elevated permissions", 'error')
      except OSError as e:
        parent._print(f"OS error removing {path_str}: {e}", 'error')
      except (IOError, shutil.Error) as e:
        parent._print(f"Failed to remove {path_str}: {e}", 'error')
      return False

    def clean(self) -> None:
      """Clean build artifacts, cache files, and temporary files."""
      parent = self.parent
      parent._print("üßπ Cleaning build artifacts and cache files...", 'info')

      # Patterns to clean
      patterns_to_remove: List[str] = [
        "**/*.pyc",
        "**/__pycache__",
        "**/.ipynb_checkpoints",
        "**/.pytest_cache",
        "build",
        "dist",
        "*.egg-info",
        "**/.mypy_cache",
        "**/.ruff_cache",
        "**/pytest.log",
      ]

      removed_count = sum(
        1 for pattern in patterns_to_remove
        for path in glob.glob(pattern, recursive=True)
        if self._remove_path(Path(path))
      )

      if removed_count > 0:
        parent._print(f"Cleaned {removed_count} items", 'success')
      else:
        parent._print("No items to clean", 'info')
      return

    def compile(self, clean_first: bool = True) -> None:
      """Build the package with Poetry, optionally cleaning artifacts first."""
      parent = self.parent

      if clean_first:
        self.clean()

      parent._print("üî® Building package with Poetry...", 'info')

      success = parent._run_command("poetry build", "Building package...")
      if success:
        # Show build info
        parent._run_command("ls -la dist/", "üìã Build information:")
        parent._print("Package built successfully!", 'success')
      else:
        parent._print("Build failed!", 'error')
      return

  class Project:
    """Project management operations including versioning, commits, and publishing."""

    def __init__(self, parent) -> None:
      """Initialize with parent FreyjaDevTools instance."""
      self.parent: 'FreyjaDevTools' = parent

    def info(self) -> None:
      """Display project environment information."""
      parent = self.parent
      parent._print("üìã Project Environment Information", 'info')
      
      # Project details
      print(f"\n{parent.colors['blue']}=== Project Details ==={parent.colors['nc']}")
      print(f"Project Source: {parent.project_src}")
      print(f"Project Name: {parent.project_name}")
      
      # Git information
      print(f"\n{parent.colors['blue']}=== Git Information ==={parent.colors['nc']}")
      
      # Current branch
      branch_result = parent._run_command(['git', 'branch', '--show-current'], capture_output=True)
      if isinstance(branch_result, subprocess.CompletedProcess) and branch_result.returncode == 0:
        print(f"Current Branch: {branch_result.stdout.strip()}")
      else:
        print("Current Branch: (unable to determine)")
      
      # Git status summary
      status_result = parent._run_command(['git', 'status', '--short'], capture_output=True)
      if isinstance(status_result, subprocess.CompletedProcess) and status_result.returncode == 0:
        status_lines = status_result.stdout.strip().split('\n') if status_result.stdout.strip() else []
        print(f"Git Status: {len(status_lines)} file(s) modified" if status_lines else "Git Status: Clean working directory")
      else:
        print("Git Status: (unable to determine)")
      
      # Python environment
      print(f"\n{parent.colors['blue']}=== Python Environment ==={parent.colors['nc']}")
      
      # Python version
      py_result = parent._run_command(['python', '--version'], capture_output=True)
      if isinstance(py_result, subprocess.CompletedProcess) and py_result.returncode == 0:
        print(f"Python Version: {py_result.stdout.strip()}")
      else:
        print("Python Version: (unable to determine)")
      
      # Poetry version
      poetry_result = parent._run_command(['poetry', '--version'], capture_output=True)
      if isinstance(poetry_result, subprocess.CompletedProcess) and poetry_result.returncode == 0:
        print(f"Poetry Version: {poetry_result.stdout.strip()}")
      else:
        print("Poetry Version: (unable to determine)")
      
      # Virtual environment
      venv_result = parent._run_command(['poetry', 'env', 'info', '--path'], capture_output=True)
      if isinstance(venv_result, subprocess.CompletedProcess) and venv_result.returncode == 0:
        print(f"Virtual Environment: {venv_result.stdout.strip()}")
      else:
        print("Virtual Environment: (not active or unable to determine)")
      
      # Additional useful info
      print(f"\n{parent.colors['blue']}=== Additional Information ==={parent.colors['nc']}")
      print(f"Working Directory: {os.getcwd()}")
      print(f"Platform: {sys.platform}")
      print(f"Python Path: {sys.executable}")
      
      # Check if running in development mode
      if Path(parent.project_src).exists():
        parent._print("\nDevelopment environment appears to be properly configured!", 'success')
      else:
        parent._print("\nWarning: Project source directory not found!", 'warning')
      
      return

    def publish(self, test_pypi: bool = False) -> None:
      """Build and publish package to PyPI or test PyPI."""
      parent = self.parent
      parent._print(f"üì¶ Building and publishing {parent.project_name} to PyPI...", 'info')

      # Clean and build first
      Build(parent).compile(clean_first=True)

      # Check for PyPI token
      token_var: str = "TEST_PYPI_TOKEN" if test_pypi else "PYPI_TOKEN"
      token_exists: bool = bool(os.environ.get(token_var))

      if token_exists:
        parent._print("üîê Configuring PyPI authentication...", 'info')

        # Configure repositories
        if test_pypi:
          repo_url = "https://test.pypi.org/legacy/"
          parent._run_command(f"poetry config repositories.testpypi {repo_url}")
          parent._run_command(f"poetry config http-basic.testpypi __token__ {os.environ[token_var]}")
          publish_cmd = "poetry publish -r testpypi"
        else:
          parent._run_command("poetry config repositories.pypi https://upload.pypi.org/legacy/")
          parent._run_command(f"poetry config http-basic.pypi __token__ {os.environ[token_var]}")
          publish_cmd = "poetry publish"

        # Publish
        success = parent._run_command(publish_cmd, "üöÄ Publishing to PyPI...")
        if success:
          if test_pypi:
            parent._print(f"Published successfully to https://test.pypi.org/project/{parent.project_name}/", 'success')
            parent._print(f"Install with: pip install --index-url https://test.pypi.org/simple/ {parent.project_name}",
                          'info')
          else:
            parent._print(f"Published successfully to https://pypi.org/project/{parent.project_name}/", 'success')
            parent._print(f"Install with: pip install {parent.project_name}", 'info')
        else:
          parent._print("Publishing failed!", 'error')
      else:
        parent._print(f"{token_var} environment variable not set", 'error')
        parent._print(f"Please set {token_var} environment variable with your PyPI token", 'error')
      return

    def _extract_commit_message(self, raw_output: str) -> Optional[str]:
      """Extract commit message from Claude response."""
      # Check for conventional commit format
      commit_pattern = re.compile(
        r'^(feat|fix|refactor|docs|style|test|chore|perf|ci|build|revert)(?:\([^)]+\))?:\s+.+', re.MULTILINE)
      match = commit_pattern.search(raw_output)
      if match:
        # Found a valid commit message - extract from that point
        start_pos = match.start()
        return raw_output[start_pos:].strip()

      # Fallback: remove code blocks if present
      code_block_match = re.search(r'```(?:text|markdown|git)?\s*\n(.*?)\n```', raw_output, re.DOTALL)
      if code_block_match:
        return code_block_match.group(1).strip()

      return None

    def autocommit(self, timeout: int = 120, retry_count: int = 3, timeout_increment: int = 60) -> None:
      """Commit all uncommitted files using Claude to generate an informative commit message.

      Args:
        timeout: Initial timeout in seconds for Claude API call (default: 120)
        retry_count: Number of times to retry on failure (default: 3)
        timeout_increment: Seconds to add per retry (default: 60)
      """
      import time
      parent = self.parent
      start_time = time.time()

      # Step 1: Check if there are any changes to commit
      step_start = time.time()
      result = parent._run_command(['git', 'status', '--porcelain'], "Checking for changes", capture_output=True)
      if not isinstance(result, subprocess.CompletedProcess) or not result.stdout.strip():
        parent._print("No changes to commit", 'info')
        return

      # Step 4: Use Claude to generate commit message with retry logic
      prompt = "Generate a git commit message for the uncommitted changes (and new non-ignored files) in this branch. Output ONLY the commit message; no preamble, introductions, explanations, nothing else."
      parent._print(
        f"ü§ñ Generating commit message with Claude (timeout: {timeout}s, retries: {retry_count}, increment: {timeout_increment}s): \n Prompt: {prompt}",
        'info')

      commit_message = parent._run_claude_prompt(prompt, retry_count=retry_count, timeout=timeout, timeout_increment=timeout_increment)
      # Try to get commit message with retries
      parent._print(f"üìù Generated commit message:\n{commit_message}", 'info')

      if commit_message:
        # Step 5: Add all files
        parent._print("üìÅ Staging all changes...", 'info')
        add_success = parent._run_command(['git', 'add', '-A'], "Staging files")

        if add_success:
          # Step 6: Commit with the generated message (allow missing pre-commit config)
          commit_env = os.environ.copy()
          commit_env['PRE_COMMIT_ALLOW_NO_CONFIG'] = '1'

          commit_success = parent._run_command(
            ['git', 'commit', '-m', commit_message],
            "Creating commit",
            env=commit_env
          )

          if commit_success:
            parent._print("üéâ Changes committed successfully!", 'success')
            # Show the commit
            parent._run_command(['git', 'log', '-1', '--oneline'], "Displaying commit")

            total_elapsed = time.time() - start_time
            parent._print(f"‚ú® Total autocommit time: {total_elapsed:.2f}s", 'success')
          else:
            parent._print("Failed to create commit", 'error')
        else:
          parent._print("Failed to stage files", 'error')
      return

    def _validate_version_format(self, version: str) -> bool:
      """Validate version format (X.Y.Z)."""
      return bool(re.match(r'^\d+\.\d+\.\d+$', version))

    def _get_current_version(self) -> Optional[str]:
      """Get the current latest tag version."""
      parent = self.parent
      result = parent._run_command(
        ['git', 'for-each-ref', '--sort=-version:refname', '--format=%(refname:short)', 'refs/tags', '--count=1'],
        capture_output=True
      )
      if isinstance(result, subprocess.CompletedProcess) and result.returncode == 0 and result.stdout.strip():
        return result.stdout.strip()
      return None

    def _increment_version(self, current: str, bump_type: str = 'patch') -> Optional[str]:
      """Increment version number."""
      version_num = current.lstrip('v')
      version_match = re.match(r'^(\d+)\.(\d+)\.(\d+)$', version_num)
      if version_match:
        major, minor, patch = map(int, version_match.groups())
        if bump_type == 'major':
          return f"{major + 1}.0.0"
        elif bump_type == 'minor':
          return f"{major}.{minor + 1}.0"
        else:  # patch
          return f"{major}.{minor}.{patch + 1}"
      return None

    def _get_committed_version(self) -> Optional[str]:
      """Get the version from the currently committed pyproject.toml."""
      parent = self.parent
      result = parent._run_command(
        ['git', 'show', 'HEAD:pyproject.toml'],
        capture_output=True
      )

      if isinstance(result, subprocess.CompletedProcess) and result.returncode == 0:
        content = result.stdout
        match = re.search(r'^version = "([^"]+)"', content, re.MULTILINE)
        if match:
          return match.group(1)
      return None

    def _update_pyproject_version(self, version: str) -> bool:
      """Update version in pyproject.toml."""
      parent = self.parent
      pyproject_path = Path("pyproject.toml")  # pyproject.toml is in project root, not package dir

      try:
        with open(pyproject_path, 'r') as f:
          content = f.read()

        # Update version line
        updated_content = re.sub(
          r'^version = "[^"]+"',
          f'version = "{version}"',
          content,
          count=1,
          flags=re.MULTILINE
        )

        with open(pyproject_path, 'w') as f:
          f.write(updated_content)

        parent._print(f"Updated pyproject.toml version to {version}", 'success')
        return True
      except FileNotFoundError:
        parent._print(f"pyproject.toml not found at {pyproject_path}", 'error')
      except PermissionError:
        parent._print(f"Permission denied writing to pyproject.toml - check file permissions", 'error')
      except IOError as e:
        parent._print(f"IO error updating pyproject.toml: {e}", 'error')
      except re.error as e:
        parent._print(f"Regex error updating version in pyproject.toml: {e}", 'error')

      return False

    def _create_git_tag(self, version: str, message: str) -> bool:
      """Create and push git tag."""
      parent = self.parent
      tag = f"v{version}"

      result = parent._run_command(
        ['git', 'tag', '-a', tag, '-m', message, 'HEAD'],
        capture_output=True
      )

      if isinstance(result, subprocess.CompletedProcess) and result.returncode == 0:
        parent._print(f"Created tag {tag} on HEAD", 'success')
        return True

      error_msg = result.stderr if hasattr(result, 'stderr') and result.stderr else "Unknown error"
      parent._print(f"Failed to create tag: {error_msg}", 'error')
      return False

    def autotag(self, version: Optional[str] = None, auto_increment: bool = True) -> None:
      """Create git tag with Claude-generated message, auto-incrementing version if needed."""
      parent = self.parent
      parent._print(f"üè∑Ô∏è  Creating {parent.project_name} version tag...", 'info')

      # Validate we're in a git repository
      result = parent._run_command(['git', 'rev-parse', '--git-dir'], capture_output=True)
      if not (isinstance(result, subprocess.CompletedProcess) and result.returncode == 0):
        parent._print("Not in a git repository", 'error')
        return

      # Determine version to use
      final_version = version

      if version is None and auto_increment:
        latest_tag = self._get_current_version()
        if latest_tag:
          parent._print(f"Latest tag: {latest_tag}", 'info')
          final_version = self._increment_version(latest_tag)
          if final_version:
            parent._print(f"Auto-incrementing to: {final_version}", 'info')
          else:
            parent._print(f"Invalid version format: {latest_tag} (expected X.Y.Z)", 'error')
        else:
          parent._print("No existing tags found. Please provide a version manually.", 'error')

      if final_version is None:
        parent._print("No version provided and auto-increment disabled", 'error')
        return

      # Clean and validate version
      final_version = final_version.lstrip('v')

      if not self._validate_version_format(final_version):
        parent._print(f"Invalid version format: {final_version} (expected X.Y.Z)", 'error')
        return

      # Check if tag already exists
      tag = f"v{final_version}"
      result = parent._run_command(['git', 'rev-parse', tag], capture_output=True)
      if isinstance(result, subprocess.CompletedProcess) and result.returncode == 0:
        parent._print(f"Tag '{tag}' already exists", 'error')
        return

      # Check if the version in the committed state is already at the target
      committed_version = self._get_committed_version()
      version_already_committed = committed_version == final_version

      if version_already_committed:
        parent._print(f"Version in HEAD is already {final_version}, skipping commit step", 'info')
      else:
        # Update version in pyproject.toml
        parent._print(f"üìù Updating version in pyproject.toml to {final_version}...", 'info')
        if not self._update_pyproject_version(final_version):
          return

        # Commit the version change
        parent._print("üíæ Committing version update...", 'info')
        if not parent._run_command(['git', 'add', 'pyproject.toml'], "Staging pyproject.toml"):
          parent._print("Failed to stage pyproject.toml", 'error')
          return

        commit_msg = f"Bump version to {final_version}"
        if not parent._run_command(['git', 'commit', '-m', commit_msg], f"Committing version bump"):
          parent._print("Failed to commit version change", 'error')
          return

      # Generate tag message with Claude
      parent._print("ü§ñ Generating tag message with Claude...", 'info')
      result = parent._run_command(
        ['poetry', 'run', 'claude', '-p',
         'Create a very short message to be used on a new tag basing it on the most recent commit (HEAD). Return a single string representing the tag description with no preamble, summary, or afterthoughts. Dont mention phases or claude AT ALL'],
        capture_output=True
      )

      tag_message = None
      if isinstance(result, subprocess.CompletedProcess) and result.returncode == 0:
        tag_message = result.stdout.strip()
        parent._print(f"Tag message: {tag_message}", 'info')
      else:
        parent._print("Failed to generate tag message with Claude", 'error')
        return

      # Create the tag
      parent._print(f"Creating tag: {tag}", 'info')
      if not self._create_git_tag(final_version, tag_message):
        return

      # Push commit and tag to remote
      parent._print("üöÄ Pushing commit and tag to remote...", 'info')
      push_success = parent._run_command(['git', 'push'], "Pushing commit to remote")
      if push_success:
        push_success = parent._run_command(['git', 'push', 'origin', tag], f"Pushing tag {tag} to remote")

      if push_success:
        parent._print("üéâ Version updated, tagged, and pushed successfully!", 'success')
        parent._print(f"Version: {final_version}", 'success')
        parent._print(f"Tag: {tag}", 'success')
        parent._print("Pushed to remote repository", 'success')
      else:
        parent._print("Failed to push to remote. Commit and tag created locally.", 'error')
        parent._print(f"To push manually, run: {parent.colors['blue']}git push && git push --tags{parent.colors['nc']}",
                      'info')
      return

  class Test:
    """Testing, diagnostics, and quality assurance operations."""

    def __init__(self, parent, coverage: bool = True) -> None:
      """Initialize with parent and optional coverage reporting."""
      self.parent: 'FreyjaDevTools' = parent
      self.coverage: bool = coverage

    def lint(self, fix: bool = False, skip_mypy: bool = False) -> None:
      """Run all linting and formatting tools, optionally auto-fixing issues.

      Args:
        fix: Auto-fix linting issues where possible
        skip_mypy: Skip MyPy type checking if True
      """
      parent = self.parent
      parent._print("üîç Running code quality checks...", 'info')

      success: bool = True

      # Big bright message before linting
      print(f"\n{parent.colors['yellow']}{'=' * 60}{parent.colors['nc']}")
      print(f"{parent.colors['yellow']}{'=' * 20} üîç LINTING... {'=' * 20}{parent.colors['nc']}")
      print(f"{parent.colors['yellow']}{'=' * 60}{parent.colors['nc']}\n")

      # Run Ruff formatting first (establishes base code style)
      ruff_format_cmd = "poetry run ruff format ."
      if not fix:
        ruff_format_cmd += " --check"
      if not parent._run_command(ruff_format_cmd, "üé® Running Ruff formatting..."):
        success = False

      # Run Ruff linting second (checks logical issues on formatted code)
      ruff_cmd = "poetry run ruff check ."
      if fix:
        ruff_cmd += " --fix"
      if not parent._run_command(ruff_cmd, "üìù Running Ruff linting..."):
        success = False

      # Run MyPy with strict type checking (unless skipped)
      if not skip_mypy:
        # Big bright message before MyPy
        print(f"\n{parent.colors['blue']}{'=' * 60}{parent.colors['nc']}")
        print(f"{parent.colors['blue']}{'=' * 18} üîß RUNNING MYPY {'=' * 18}{parent.colors['nc']}")
        print(f"{parent.colors['blue']}{'=' * 60}{parent.colors['nc']}\n")

        # Use actual package name instead of git repo name
        package_name = parent.project_src  # The actual Python package name
        mypy_cmd = f"poetry run mypy {package_name}"
        # Generate reports if directories exist
        reports_dir = Path(parent.project_src) / "reports" / "mypy"
        if reports_dir.exists():
          mypy_cmd += f" --html-report {reports_dir} --linecount-report {reports_dir} --linecoverage-report {reports_dir}"
        if not parent._run_command(mypy_cmd, "üîß Running MyPy type checking..."):
          success = False
      else:
        parent._print("‚è≠Ô∏è  Skipping MyPy type checking (--skip-mypy)", 'info')

      if success:
        parent._print("All code quality checks passed!", 'success')
        sys.exit(0)
      else:
        parent._print("Some code quality checks failed!", 'error')
        sys.exit(1)

    def unit(self, pattern: str = "", parallel: bool = False, verbose_output: bool = False) -> None:
      """Run unit tests with optional filtering, parallelization, and coverage."""
      parent = self.parent
      parent._print("üß™ Running unit tests with coverage...", 'info')

      # Build test command - use pytest marks to select unit tests
      cmd_parts: List[str] = ["poetry", "run", "pytest"]

      if self.coverage:
        cmd_parts.extend([f"--cov={parent.project_name}", "--cov-report=term-missing", "--cov-report=html"])

      if verbose_output:
        cmd_parts.append("-v")

      if parallel:
        cmd_parts.append("-n auto")

      # Use pytest mark to select only unit tests
      cmd_parts.extend(["-m", "unit"])

      if pattern:
        cmd_parts.extend(["-k", pattern])

      success = parent._run_command(cmd_parts)
      if success:
        parent._print("üìä Coverage report generated in htmlcov/", 'info')
        parent._print("Unit tests completed successfully!", 'success')
      else:
        parent._print("Unit tests failed!", 'error')
      return

    def integration(self, pattern: str = "", parallel: bool = False, verbose_output: bool = False) -> None:
      """Run integration tests with optional filtering, parallelization, and coverage."""
      parent = self.parent
      parent._print("üîó Running integration tests...", 'info')

      # Build test command - use pytest marks to select integration tests
      cmd_parts: List[str] = ["poetry", "run", "pytest"]

      if self.coverage:
        cmd_parts.extend([f"--cov={parent.project_name}", "--cov-report=term-missing", "--cov-report=html"])

      if verbose_output:
        cmd_parts.append("-v")

      if parallel:
        cmd_parts.append("-n auto")

      # Use pytest mark to select only integration tests
      cmd_parts.extend(["-m", "integration"])

      if pattern:
        cmd_parts.extend(["-k", pattern])

      success = parent._run_command(cmd_parts)
      if success:
        parent._print("üìä Coverage report generated in htmlcov/", 'info')
        parent._print("Integration tests completed successfully!", 'success')
      else:
        parent._print("Integration tests failed!", 'error')
      return

    def all(self, pattern: str = "", parallel: bool = False, verbose_output: bool = False) -> None:
      """Run all tests (unit and integration) with optional filtering, parallelization, and coverage."""
      parent = self.parent
      parent._print("üß™ Running all tests (unit and integration)...", 'info')

      # Build test command - run both unit and integration tests
      cmd_parts: List[str] = ["poetry", "run", "pytest"]

      if self.coverage:
        cmd_parts.extend([f"--cov={parent.project_name}", "--cov-report=term-missing", "--cov-report=html"])

      if verbose_output:
        cmd_parts.append("-v")

      if parallel:
        cmd_parts.append("-n auto")

      # Use pytest marks to select both unit and integration tests
      cmd_parts.extend(["-m", "unit or integration"])

      if pattern:
        cmd_parts.extend(["-k", pattern])

      success = parent._run_command(cmd_parts)
      if success:
        parent._print("üìä Coverage report generated in htmlcov/", 'info')
        parent._print("All tests completed successfully!", 'success')
      else:
        parent._print("Some tests failed!", 'error')
      return

    def completion(self, examples_only: bool = False) -> None:
      """Test shell completion functionality, optionally just examples."""
      parent = self.parent
      parent._print("üîß Testing shell completion functionality...", 'info')

      # Set up environment
      os.environ['PYTHONPATH'] = str(parent.project_src)
      os.chdir(parent.project_src)

      tests_passed: int = 0
      tests_failed: int = 0
      critical_failures: int = 0

      def run_completion_test(test_name: str, test_command: str, expected_pattern: str, critical: bool = False) -> bool:
        nonlocal tests_passed, tests_failed, critical_failures

        test_result: bool = False

        if parent.verbose:
          print(f"Running test: {test_name}")
          print(f"Command: {test_command}")

        result = parent._run_command(shlex.split(test_command), capture_output=True, timeout=10)

        if isinstance(result, subprocess.CompletedProcess):
          if result.returncode == 0 and (expected_pattern in result.stdout or expected_pattern in result.stderr):
            if parent.verbose:
              parent._print(f"‚úÖ {test_name}", 'success')
            tests_passed += 1
            test_result = True
          else:
            parent._print(f"‚ùå {test_name}", 'error')
            if parent.verbose:
              print(f"Expected pattern: {expected_pattern}")
              if hasattr(result, 'stdout'):
                print(f"Stdout: {result.stdout[:200]}")
              if hasattr(result, 'stderr'):
                print(f"Stderr: {result.stderr[:200]}")
            tests_failed += 1
            if critical:
              critical_failures += 1
        else:
          # Timeout or other error
          parent._print(f"‚è∞ {test_name} - TIMEOUT or ERROR", 'error')
          tests_failed += 1
          if critical:
            critical_failures += 1

        return test_result

      # Test basic completion functionality
      if not examples_only:
        parent._print("Testing basic completion system...", 'info')

        # Test help completion
        run_completion_test(
          "Help completion",
          "python examples/cls_example --help",
          "usage:",
          critical=True
        )

        # Test command completion
        run_completion_test(
          "Command completion",
          "python examples/cls_example completion install",
          "completion",
          critical=False
        )

      # Test examples completion
      parent._print("Testing examples completion...", 'info')

      # Test cls_example basic functionality
      run_completion_test(
        "cls_example help",
        "python examples/cls_example --help",
        "usage:",
        critical=True
      )

      # Test cls_example command execution
      run_completion_test(
        "cls_example command execution",
        "python examples/cls_example file-operations--process-single --input-file test.txt --dry-run",
        "test.txt",
        critical=False
      )

      # Test multi-class example
      run_completion_test(
        "multi_class_example help",
        "python examples/multi_class_example --help",
        "usage:",
        critical=False
      )

      # Print results
      total_tests: int = tests_passed + tests_failed
      parent._print(f"Completion test results: {tests_passed}/{total_tests} passed", 'info')

      if critical_failures > 0:
        parent._print(f"‚ùå {critical_failures} critical failures detected!", 'error')
      elif tests_failed > 0:
        parent._print(f"‚ö†Ô∏è  {tests_failed} non-critical tests failed", 'warning')
      else:
        parent._print("All completion tests passed!", 'success')
      return

    def diagnose(self, include_env: bool = True, include_completion: bool = True) -> None:
      """Run comprehensive diagnostic analysis for development issues."""
      parent = self.parent
      parent._print("üîç Running comprehensive diagnostic analysis...", 'info')

      if include_env:
        parent._print("=== Environment Variable Analysis ===", 'info')
        print(f"Current shell: {os.environ.get('SHELL', 'Unknown')}")
        print(f"Current PID: {os.getpid()}")
        print()

        # Check project-related environment variables
        project_vars: Dict[str, str] = {k: v for k, v in os.environ.items() if
                                        parent.project_name.lower() in k.lower() or 'comp_' in k.lower()}
        if project_vars:
          print(f"{parent.project_name.capitalize()} completion environment variables:")
          for k, v in project_vars.items():
            print(f"  {k}={v}")
        else:
          print(f"No {parent.project_name.capitalize()} completion environment variables found")
        print()

      if include_completion:
        parent._print("=== Completion System Analysis ===", 'info')

        # Test completion system availability
        result = parent._run_command(
          ['python', 'examples/cls_example', 'completion', '--help'],
          capture_output=True,
          timeout=5
        )
        if isinstance(result, subprocess.CompletedProcess) and result.returncode == 0:
          parent._print("Completion system is available", 'success')
        else:
          parent._print("Completion system unavailable or broken", 'error')

        # Test shell-specific completion
        shell: str = os.environ.get('SHELL', '')
        if 'bash' in shell:
          parent._run_command(f"complete -p | grep -i {parent.project_name} || echo 'No bash completion found'",
                              "Bash completion status:")
        elif 'zsh' in shell:
          parent._run_command(f"compdef | grep -i {parent.project_name} || echo 'No zsh completion found'",
                              "Zsh completion status:")

        print()

      # Python environment check
      parent._print("=== Python Environment ===", 'info')
      parent._run_command("poetry run python --version", "Python version:")
      parent._run_command(
        f"poetry run python -c 'import {parent.project_name}; print(f\"{parent.project_name.capitalize()} module: {{{parent.project_name}.__file__}}\")'",
        f"{parent.project_name.capitalize()} module location:")

      # Project structure check
      parent._print("=== Project Structure ===", 'info')
      important_files: List[str] = [
        "pyproject.toml",
        f"{parent.project_name}/__init__.py",
        "examples/cls_example",
        "examples/multi_class_example"
      ]

      for file_path in important_files:
        full_path: Path = Path(parent.project_src) / file_path
        if full_path.exists():
          parent._print(f"‚úÖ {file_path} exists", 'success')
        else:
          parent._print(f"‚ùå {file_path} missing", 'error')

      parent._print("Diagnostic analysis complete!", 'success')
      return


if __name__ == '__main__':
  # Create the CLI instance and store reference for inner classes
  dev_tools = FreyjaDevTools()
  sys.modules[__name__].__dict__['_parent_instance'] = dev_tools

  cli = FreyjaCLI(FreyjaDevTools, title=f"{dev_tools.project_name.capitalize()} Development Tools")
  result = cli.run()
  sys.exit(result if isinstance(result, int) else 0)
