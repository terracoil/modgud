#!/usr/bin/env python3
"""
Development Tools CLI
Consolidates all development scripts into a single FreyjaCLI implementation.
"""
import glob
import os
import re
import shlex
import shutil
import subprocess
import sys
import time
import tomllib
from pathlib import Path
from subprocess import CompletedProcess
from typing import Dict, List, Optional, Union

from modgud.util import Vector, VectorPath, VectorProtocol

# Add the project root to the Python path
sys.path.insert(0, str(Path(__file__).parent.parent))

from freyja import FreyjaCLI


# Configure cache directories to use tmp/
# os.environ.setdefault('RUFF_CACHE_DIR', str(project_src / 'tmp' / '.ruff_cache'))


class FreyjaDevTools:
  """Development toolkit with build, test, and setup commands organized via Freyja's inner class pattern."""

  def __init__(self, verbose: bool = False, dry_run: bool = False) -> None:
    """Initialize with optional verbose output and dry-run mode."""
    self.verbose: bool = verbose
    self.dry_run: bool = dry_run
    self.colors: Dict[str, str] = {
      'red': '\033[0;31m',
      'green': '\033[0;32m',
      'yellow': '\033[1;33m',
      'blue': '\033[0;34m',
      'nc': '\033[0m'  # No Color
    }

    self.project_src: str = self.get_project_src()
    self.project_name: str = self.get_project_name()

    # Configure cache directories to use tmp/
    os.environ.setdefault('RUFF_CACHE_DIR', str(Path(self.project_src) / 'tmp' / '.ruff_cache'))

  @classmethod
  def get_project_src(cls) -> str:
    """Get pyproject source root"""
    with open("pyproject.toml", "rb") as f:
      proj_map = tomllib.load(f)

      # proj_root: str = ""
      try:
        proj_root: str = proj_map["tool"]["poetry"]["packages"][0]["include"]
      except Exception as x:
        print(f"Error getting proj_root; falling back to project_name: {x}")
        proj_root: str = cls.get_project_name()

    print(proj_root)
    return proj_root

  @classmethod
  def get_project_name(cls) -> str:
    """Get project name from pyproject.toml"""
    with open("pyproject.toml", "rb") as f:
      proj_map = tomllib.load(f)
      return proj_map["project"]["name"]

  def _format_command(self, command: Union[str, List[str]], shell: bool) -> Union[str, List[str]]:
    """Convert string command to list format if needed."""
    # Convert string to list if shell=False for safety
    if isinstance(command, str) and not shell:
      return shlex.split(command)
    return command

  def _display_command(self, command: Union[str, List[str]], cwd: Optional[str] = None) -> None:
    """Display command in verbose/dry-run mode."""
    cmd_display = command if isinstance(command, str) else ' '.join(shlex.quote(arg) for arg in command)
    if self.verbose or self.dry_run:
      print(f"Command: {cmd_display}")

    if self.dry_run:
      print("(DRY RUN - command not executed)")

  def _execute_subprocess(self, command: Union[str, List[str]], **kwargs) -> subprocess.CompletedProcess:
    """Execute subprocess with configured parameters."""
    # Set default cwd if not provided
    if 'cwd' not in kwargs:
      kwargs['cwd'] = self.project_src
    return subprocess.run(command, **kwargs)

  def _handle_subprocess_error(self, e: Exception, command: Union[str, List[str]],
                               capture_output: bool, check: bool) -> Union[bool, subprocess.CompletedProcess]:
    """Unified error handling for subprocess failures."""
    if isinstance(e, subprocess.CalledProcessError):
      if not capture_output:
        self._print(f"Command failed with exit code {e.returncode}", 'error')
      if check:
        raise
      return e if capture_output else False
    elif isinstance(e, subprocess.TimeoutExpired):
      if not capture_output:
        self._print(f"Command timed out after {e.timeout} seconds", 'error')
      if check:
        raise
      return subprocess.CompletedProcess(command, -1, '', 'Timeout') if capture_output else False
    elif isinstance(e, FileNotFoundError):
      cmd_name = command[0] if isinstance(command, list) and command else str(command).split()[0]
      if not capture_output:
        self._print(f"Command '{cmd_name}' not found - is it installed and in PATH?", 'error')
      return subprocess.CompletedProcess(command, -1, '', f"Command not found: {cmd_name}") if capture_output else False
    elif isinstance(e, OSError):
      if not capture_output:
        self._print(f"OS error running command: {e}", 'error')
      return subprocess.CompletedProcess(command, -1, '', str(e)) if capture_output else False
    else:
      raise  # Re-raise unexpected exceptions

  def _run_claude_prompt(self, prompt, retry_count=2, timeout=60, timeout_increment=60):
    claude_result: CompletedProcess | None = None
    last_error: str | None = None

    # Build Claude command
    claude_cmd = ['poetry', 'run', 'claude', '-p', prompt]

    for attempt in range(retry_count + 1):
      # Calculate timeout for this attempt
      current_timeout = timeout + (attempt * timeout_increment)

      if attempt > 0:
        self._print(f"ðŸ”„ Retrying... (attempt {attempt + 1}/{retry_count + 1})", 'warning')

      self._print(f"â³ Calling Claude API (attempt {attempt + 1}/{retry_count + 1}, timeout: {current_timeout}s)...",
                  'info')

      # Run with detailed timing and progress monitoring
      api_start = time.time()
      try:
        claude_result = self._run_command(
          claude_cmd,
          capture_output=True,
          timeout=current_timeout
        )
        api_elapsed = time.time() - api_start
        self._print(f"Claude API call (attempt {attempt + 1}) after {api_elapsed:.2f}s")

        # Check if command succeeded
        if claude_result and claude_result.returncode == 0:
          break
        else:
          api_elapsed = time.time() - api_start
          error_msg = claude_result.stderr if claude_result else "Command failed"
          self._print(f"âŒ Claude API call failed after {api_elapsed:.2f}s: {error_msg}", 'error')
          last_error = f"Claude API failed: {error_msg}"
          continue

      except subprocess.TimeoutExpired as e:
        api_elapsed = time.time() - api_start
        self._print(f"â° Timeout after {api_elapsed:.2f}s (limit was {current_timeout}s)", 'error')
        last_error = f"Claude API timed out after {api_elapsed:.2f}s"
        continue

    if claude_result:
      commit_message = claude_result.stdout.strip()
    else:
      raise RuntimeError(f"Error running claude command: {claude_cmd}: {last_error}")

    return commit_message

  def _run_command(
      self,
      command: Union[str, List[str]],
      description: str = "",
      shell: bool = False,
      capture_output: bool = False,
      check: bool = False,
      timeout: Optional[int] = None,
      cwd=None,
      env=None
  ) -> Union[bool, subprocess.CompletedProcess]:
    """Execute a command with unified error handling and logging.

    Returns bool for compatibility, or CompletedProcess when capture_output=True."""
    if description:
      print(f"{self.colors['blue']}{description}{self.colors['nc']}")

    # Format command
    command = self._format_command(command, shell)

    # Display command for verbose/dry-run
    self._display_command(command)

    # Track result value for single return point
    result_value = None

    if self.dry_run:
      # Set mock result for dry-run
      result_value = subprocess.CompletedProcess(command, 0, '', '') if capture_output else True
    else:
      try:
        result = self._execute_subprocess(
          command,
          shell=shell,
          check=check,
          capture_output=capture_output,
          text=capture_output,  # Use text mode when capturing
          timeout=timeout,
          cwd=cwd,
          env=env
        )
        result_value = result if capture_output else (result.returncode == 0)
      except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
        result_value = self._handle_subprocess_error(e, command, capture_output, check)

    return result_value

  def _print(self, message: str, msg_type: str = 'info') -> None:
    """Print formatted message based on type."""
    icons = {'success': 'âœ…', 'error': 'âŒ', 'info': 'â„¹ï¸', 'warning': 'âš ï¸'}
    colors = {'success': 'green', 'error': 'red', 'info': 'blue', 'warning': 'yellow'}

    color = self.colors.get(colors.get(msg_type, 'blue'), self.colors['blue'])
    icon = icons.get(msg_type, 'â„¹ï¸')
    print(f"{color}{icon} {message}{self.colors['nc']}")

  class Setup:
    """Development environment and self-installation setup operations."""

    def __init__(self, parent) -> None:
      """Initialize with parent FreyjaDevTools instance."""
      self.parent: 'FreyjaDevTools' = parent

    def env(self) -> None:
      """Set up the development environment with dependencies and pre-commit hooks."""
      parent = self.parent
      print(
        f"{parent.colors['blue']}ðŸš€ Setting up development environment for {parent.project_name}...{parent.colors['nc']}")

      # Install dependencies
      success = parent._run_command("poetry install --with dev", "ðŸ“¦ Installing dependencies with Poetry...")
      if success:
        # Install pre-commit hooks
        success = parent._run_command("poetry run pre-commit install", "ðŸª Installing pre-commit hooks...")
        if success:
          # Verify Python version
          parent._run_command("poetry run python --version", "ðŸ Python version:", cwd=parent.project_src)
          parent._print("Development environment setup complete!", 'success')
          print()
          print("Available commands:")
          parent._run_command("poetry run bin/devtools")
        else:
          parent._print("Failed to install pre-commit hooks", 'error')
      else:
        parent._print("Failed to install dependencies", 'error')

    def self(self, force: bool = False) -> None:
      """Compile and install the latest version from dist/, optionally forcing reinstallation."""
      parent = self.parent
      parent._print(f"ðŸ”§ Building and installing latest {parent.project_name} version...", 'info')

      # First, build the package
      parent._print("Building package first...", 'info')
      success = parent._run_command("poetry build", "ðŸ”¨ Building package...")

      if success:
        # Find the latest wheel file
        dist_dir = Path(parent.project_src) / "dist"
        if dist_dir.exists():
          wheel_files = list(dist_dir.glob("*.whl"))
          if wheel_files:
            # Get the latest wheel file (by modification time)
            latest_wheel = max(wheel_files, key=lambda p: p.stat().st_mtime)
            parent._print(f"Installing wheel: {latest_wheel.name}", 'info')

            # Install the wheel
            install_cmd = f"pip install {latest_wheel}"
            if force:
              install_cmd += " --force-reinstall"

            success = parent._run_command(install_cmd, f"ðŸ“¦ Installing {latest_wheel.name}...")
            if success:
              # Verify installation
              parent._run_command(
                f"python -c 'import {parent.project_name}; print(f\"{parent.project_name.capitalize()} version: {{{parent.project_name}.__version__ if hasattr({parent.project_name}, \"__version__\") else \"unknown\"}}\"); print(f\"{parent.project_name.capitalize()} location: {{{parent.project_name}.__file__}}\")'",
                "ðŸ” Verifying installation:"
              )
              parent._print("Self-installation complete!", 'success')
              parent._print(f"You can now use '{parent.project_name}' from anywhere on your system", 'info')
            else:
              parent._print("Installation failed!", 'error')
          else:
            parent._print("No wheel files found in dist/. Build may have failed.", 'error')
        else:
          parent._print("dist/ dir not found. Run build first.", 'error')
      else:
        parent._print("Build failed!", 'error')

  class Build:
    """Build and compilation operations."""

    def __init__(self, parent, parallel: bool = True) -> None:
      """Initialize with parent and optional parallel execution."""
      self.parent: 'FreyjaDevTools' = parent
      self.parallel: bool = parallel

    def _remove_path(self, path_obj: Path) -> bool:
      """Remove a single file or dir with error handling."""
      parent = self.parent
      path_str = str(path_obj)

      try:
        if path_obj.is_dir():
          if not parent.dry_run:
            shutil.rmtree(path_obj)
          if parent.verbose or parent.dry_run:
            print(f"Removed dir: {path_str}")
        elif path_obj.is_file():
          if not parent.dry_run:
            path_obj.unlink()
          if parent.verbose or parent.dry_run:
            print(f"Removed file: {path_str}")
        return True
      except PermissionError:
        parent._print(f"Permission denied removing {path_str} - try running with elevated permissions", 'error')
      except OSError as e:
        parent._print(f"OS error removing {path_str}: {e}", 'error')
      except (IOError, shutil.Error) as e:
        parent._print(f"Failed to remove {path_str}: {e}", 'error')
      return False

    def clean(self) -> None:
      """Clean build artifacts, cache files, and temporary files."""
      parent = self.parent
      parent._print("ðŸ§¹ Cleaning build artifacts and cache files...", 'info')

      # Patterns to clean
      patterns_to_remove: List[str] = [
        "**/*.pyc",
        "**/__pycache__",
        "**/.ipynb_checkpoints",
        "**/.pytest_cache",
        "build",
        "target",
        "demo*",
        "dist",
        "generated*",
        "output*",
        "tmp*",
        "*.egg-info",
        "**/.mypy_cache",
        "**/.ruff_cache",
        "**/pytest.log",
      ]

      removed_count = sum(
        1 for pattern in patterns_to_remove
        for path in glob.glob(pattern, recursive=True)
        if self._remove_path(Path(path))
      )

      if removed_count > 0:
        parent._print(f"Cleaned {removed_count} items", 'success')
      else:
        parent._print("No items to clean", 'info')
      return

    def compile(self, clean_first: bool = True) -> None:
      """Build the package with Poetry, optionally cleaning artifacts first."""
      parent = self.parent

      if clean_first:
        self.clean()

      parent._print("ðŸ”¨ Building package with Poetry...", 'info')

      success = parent._run_command("poetry build", "Building package...")
      if success:
        # Show build info
        parent._run_command("ls -la dist/", "ðŸ“‹ Build information:")
        parent._print("Package built successfully!", 'success')
      else:
        parent._print("Build failed!", 'error')
      return

  class Project:
    """Project management operations including versioning, commits, and publishing."""

    def __init__(self, parent) -> None:
      """Initialize with parent FreyjaDevTools instance."""
      self.parent: 'FreyjaDevTools' = parent

    def dovetail(self, dovetail_pct: float = 0.1, teeth_cnt: int = 5, buffer_pct=0.5,
                         width: float = 100.0) -> str:
      """
        Calculate the coordinates of the points to plot
        Uses 1/2 tooth each for stub ends.
      """
      tooth_height_pct = 0.5
      segment_base = width / (teeth_cnt+1.0)
      dovetail_diff = segment_base * dovetail_pct
      dovetail_width = segment_base + dovetail_diff
      groove_height = segment_base * tooth_height_pct
      stub_width = dovetail_width / 2.0

      if dovetail_diff > stub_width / 2.0:
        raise ValueError(f"dovetail_pct is too great.  It should be {dovetail_pct * stub_width / 2.0} ")

      # Point = tuple[float, float]

      def add_tooth(down: bool, tooth_id: int) -> list[VectorProtocol]:
        direction: float = 1 if down else -1
        dir_str = "Down" if down else "Up"
        name = f"{dir_str} Tooth #{tooth_id:02d}"
        return [
          Vector(-dovetail_diff, groove_height * direction, name=name),
          Vector(dovetail_width, 0),
          Vector(-dovetail_diff, -groove_height * direction)
        ] if down else [(Vector(dovetail_width, 0))]

      path_top: VectorPath = VectorPath(Vector(0, 50), name="dovetailTop")
      path_top.add_relative_segment(Vector(stub_width, 0, name="leftStub"))
      down: bool = True
      for t in range(teeth_cnt):
        tooth_segments: list[VectorProtocol] = add_tooth(down=down, tooth_id=t + 1)
        path_top.add_relative_segment(tooth_segments)
        down = not down

      path_top.add_relative_segment(Vector(stub_width, 0, name="rightStub"))
      path_teeth: VectorPath = path_top.clone("dovetailTeeth")
      path_bot: VectorPath = path_top.clone("dovetailBot")

      # Enclose paths to make a whole area:
      path_top.add_relative_segment(Vector(0, -50, name="topEnclosure"))
      path_top.add_relative_segment(Vector(-100, 0))

      path_bot.add_relative_segment(Vector(0, 50, name="botEnclosure"))
      path_bot.add_relative_segment(Vector(-100, 0))

      svg_top = list(path_top.svg_path(True))
      svg_bot = list(path_bot.svg_path(True))
      svg_teeth = list(path_teeth.svg_path(True))

      max_len =max(len(svg_top), len(svg_bot), len(svg_teeth))

      print(f"{'Top':<40}{'Bottom':<40}{'Teeth':<40}")
      for i in range(max_len):
        top:str = svg_top[i] if i < len(svg_top) else ''
        bot:str = svg_bot[i] if i < len(svg_bot) else ''
        tth:str = svg_teeth[i] if i < len(svg_teeth) else ''
        print(f"{top:<40}{bot:<40}{tth:<40}")

      return "\n\n".join([top, bot])

    def info(self) -> None:
      """Display project environment information."""
      parent = self.parent
      parent._print("ðŸ“‹ Project Environment Information", 'info')

      # Project details
      print(f"\n{parent.colors['blue']}=== Project Details ==={parent.colors['nc']}")
      print(f"Project Source: {parent.project_src}")
      print(f"Project Name: {parent.project_name}")

      # Git information
      print(f"\n{parent.colors['blue']}=== Git Information ==={parent.colors['nc']}")

      # Current branch
      branch_result = parent._run_command(['git', 'branch', '--show-current'], capture_output=True)
      if isinstance(branch_result, subprocess.CompletedProcess) and branch_result.returncode == 0:
        print(f"Current Branch: {branch_result.stdout.strip()}")
      else:
        print("Current Branch: (unable to determine)")

      # Git status summary
      status_result = parent._run_command(['git', 'status', '--short'], capture_output=True)
      if isinstance(status_result, subprocess.CompletedProcess) and status_result.returncode == 0:
        status_lines = status_result.stdout.strip().split('\n') if status_result.stdout.strip() else []
        print(f"Git Status: {len(status_lines)} file(s) modified" if status_lines else "Git Status: Clean working dir")
      else:
        print("Git Status: (unable to determine)")

      # Python environment
      print(f"\n{parent.colors['blue']}=== Python Environment ==={parent.colors['nc']}")

      # Python version
      py_result = parent._run_command(['python', '--version'], capture_output=True)
      if isinstance(py_result, subprocess.CompletedProcess) and py_result.returncode == 0:
        print(f"Python Version: {py_result.stdout.strip()}")
      else:
        print("Python Version: (unable to determine)")

      # Poetry version
      poetry_result = parent._run_command(['poetry', '--version'], capture_output=True)
      if isinstance(poetry_result, subprocess.CompletedProcess) and poetry_result.returncode == 0:
        print(f"Poetry Version: {poetry_result.stdout.strip()}")
      else:
        print("Poetry Version: (unable to determine)")

      # Virtual environment
      venv_result = parent._run_command(['poetry', 'env', 'info', '--path'], capture_output=True)
      if isinstance(venv_result, subprocess.CompletedProcess) and venv_result.returncode == 0:
        print(f"Virtual Environment: {venv_result.stdout.strip()}")
      else:
        print("Virtual Environment: (not active or unable to determine)")

      # Additional useful info
      print(f"\n{parent.colors['blue']}=== Additional Information ==={parent.colors['nc']}")
      print(f"Working Directory: {os.getcwd()}")
      print(f"Platform: {sys.platform}")
      print(f"Python Path: {sys.executable}")

      # Check if running in development mode
      if Path(parent.project_src).exists():
        parent._print("\nDevelopment environment appears to be properly configured!", 'success')
      else:
        parent._print("\nWarning: Project source dir not found!", 'warning')

      return

    def publish(self, test_pypi: bool = False) -> None:
      """Build and publish package to PyPI or test PyPI."""
      parent = self.parent
      parent._print(f"ðŸ“¦ Building and publishing {parent.project_name} to PyPI...", 'info')

      # Clean and build first
      FreyjaDevTools.Build(parent).compile(clean_first=True)

      # Check for PyPI token
      token_var: str = "TEST_PYPI_TOKEN" if test_pypi else "PYPI_TOKEN"
      token_exists: bool = bool(os.environ.get(token_var))

      if token_exists:
        parent._print("ðŸ” Configuring PyPI authentication...", 'info')

        # Configure repositories
        if test_pypi:
          repo_url = "https://test.pypi.org/legacy/"
          parent._run_command(f"poetry config repositories.testpypi {repo_url}")
          parent._run_command(f"poetry config http-basic.testpypi __token__ {os.environ[token_var]}")
          publish_cmd = "poetry publish -r testpypi"
        else:
          parent._run_command("poetry config repositories.pypi https://upload.pypi.org/legacy/")
          parent._run_command(f"poetry config http-basic.pypi __token__ {os.environ[token_var]}")
          publish_cmd = "poetry publish"

        # Publish
        success = parent._run_command(publish_cmd, "ðŸš€ Publishing to PyPI...")
        if success:
          if test_pypi:
            parent._print(f"Published successfully to https://test.pypi.org/project/{parent.project_name}/", 'success')
            parent._print(f"Install with: pip install --index-url https://test.pypi.org/simple/ {parent.project_name}",
                          'info')
          else:
            parent._print(f"Published successfully to https://pypi.org/project/{parent.project_name}/", 'success')
            parent._print(f"Install with: pip install {parent.project_name}", 'info')
        else:
          parent._print("Publishing failed!", 'error')
      else:
        parent._print(f"{token_var} environment variable not set", 'error')
        parent._print(f"Please set {token_var} environment variable with your PyPI token", 'error')
      return

    def _extract_commit_message(self, raw_output: str) -> Optional[str]:
      """Extract commit message from Claude response."""
      # Check for conventional commit format
      commit_pattern = re.compile(
        r'^(feat|fix|refactor|docs|style|test|chore|perf|ci|build|revert)(?:\([^)]+\))?:\s+.+', re.MULTILINE)
      match = commit_pattern.search(raw_output)
      if match:
        # Found a valid commit message - extract from that point
        start_pos = match.start()
        return raw_output[start_pos:].strip()

      # Fallback: remove code blocks if present
      code_block_match = re.search(r'```(?:text|markdown|git)?\s*\n(.*?)\n```', raw_output, re.DOTALL)
      if code_block_match:
        return code_block_match.group(1).strip()

      return None

    def autocommit(self, timeout: int = 120, retry_count: int = 3, timeout_increment: int = 60) -> None:
      """
      Commit all uncommitted files using Claude to generate an informative commit message.

      :param timeout: Initial timeout in seconds for Claude API call (default: 120)
      :param retry_count: Number of times to retry on failure (default: 3)
      :param timeout_increment: Seconds to add per retry (default: 60)
      """
      import time


      parent = self.parent
      start_time = time.time()

      # Step 1: Check if there are any changes to commit
      step_start = time.time()
      result = parent._run_command(['git', 'status', '--porcelain'], "Checking for changes", capture_output=True)
      if not isinstance(result, subprocess.CompletedProcess) or not result.stdout.strip():
        parent._print("No changes to commit", 'info')
        return

      # Step 4: Use Claude to generate commit message with retry logic
      prompt = "Write a single-line git commit message based on all the currently uncommited code, using conventional commit format. Output ONLY the commit message with no analysis, explanation, or phrases like 'Based on' or 'I can see'. Do not mention Claude or AI tools."
      parent._print(
        f"ðŸ¤– Generating commit message with Claude (timeout: {timeout}s, retries: {retry_count}, increment: {timeout_increment}s): \n Prompt: {prompt}",
        'info')

      commit_message = parent._run_claude_prompt(prompt, retry_count=retry_count, timeout=timeout,
                                                 timeout_increment=timeout_increment)

      # Check for problematic phrases and regenerate if found
      problematic_phrases = ["Based on the git diff", "I can see", "Now I can see", "This is a",
                             "Looking at the changes", "The changes show"]
      if any(phrase in commit_message for phrase in problematic_phrases):
        parent._print(f"âš ï¸ Generated message contains analytical text, regenerating...", 'warning')
        simple_prompt = "Generate a git commit message. Output only the message, no explanation."
        commit_message = parent._run_claude_prompt(simple_prompt, retry_count=1, timeout=30)

      parent._print(f"ðŸ“ Generated commit message:\n{commit_message}", 'info')

      if commit_message:
        # Step 5: Add all files
        parent._print("ðŸ“ Staging all changes...", 'info')
        add_success = parent._run_command(['git', 'add', '-A'], "Staging files")

        if add_success:
          # Step 6: Commit with the generated message (allow missing pre-commit config)
          commit_env = os.environ.copy()
          commit_env['PRE_COMMIT_ALLOW_NO_CONFIG'] = '1'

          commit_success = parent._run_command(
            ['git', 'commit', '-m', commit_message],
            "Creating commit",
            env=commit_env
          )

          if commit_success:
            parent._print("ðŸŽ‰ Changes committed successfully!", 'success')
            # Show the commit
            parent._run_command(['git', 'log', '-1', '--oneline'], "Displaying commit")

            total_elapsed = time.time() - start_time
            parent._print(f"âœ¨ Total autocommit time: {total_elapsed:.2f}s", 'success')
          else:
            parent._print("Failed to create commit", 'error')
        else:
          parent._print("Failed to stage files", 'error')
      return

    def _validate_version_format(self, version: str) -> bool:
      """Validate version format (X.Y.Z)."""
      return bool(re.match(r'^\d+\.\d+\.\d+$', version))

    def _get_current_version(self) -> Optional[str]:
      """Get the current latest tag version."""
      parent = self.parent
      result = parent._run_command(
        ['git', 'for-each-ref', '--sort=-version:refname', '--format=%(refname:short)', 'refs/tags', '--count=1'],
        capture_output=True
      )
      if isinstance(result, subprocess.CompletedProcess) and result.returncode == 0 and result.stdout.strip():
        return result.stdout.strip()
      return None

    def _increment_version(self, current: str, bump_type: str = 'patch') -> Optional[str]:
      """Increment version number."""
      version_num = current.lstrip('v')
      version_match = re.match(r'^(\d+)\.(\d+)\.(\d+)$', version_num)
      if version_match:
        major, minor, patch = map(int, version_match.groups())
        if bump_type == 'major':
          return f"{major + 1}.0.0"
        elif bump_type == 'minor':
          return f"{major}.{minor + 1}.0"
        else:  # patch
          return f"{major}.{minor}.{patch + 1}"
      return None

    def _get_committed_version(self) -> Optional[str]:
      """Get the version from the currently committed pyproject.toml."""
      parent = self.parent
      result = parent._run_command(
        ['git', 'show', 'HEAD:pyproject.toml'],
        capture_output=True
      )

      if isinstance(result, subprocess.CompletedProcess) and result.returncode == 0:
        content = result.stdout
        match = re.search(r'^version = "([^"]+)"', content, re.MULTILINE)
        if match:
          return match.group(1)
      return None

    def _update_pyproject_version(self, version: str) -> bool:
      """Update version in pyproject.toml."""
      parent = self.parent
      pyproject_path = Path("pyproject.toml")  # pyproject.toml is in project root, not package dir

      try:
        with open(pyproject_path, 'r') as f:
          content = f.read()

        # Update version line
        updated_content = re.sub(
          r'^version = "[^"]+"',
          f'version = "{version}"',
          content,
          count=1,
          flags=re.MULTILINE
        )

        with open(pyproject_path, 'w') as f:
          f.write(updated_content)

        parent._print(f"Updated pyproject.toml version to {version}", 'success')
        return True
      except FileNotFoundError:
        parent._print(f"pyproject.toml not found at {pyproject_path}", 'error')
      except PermissionError:
        parent._print(f"Permission denied writing to pyproject.toml - check file permissions", 'error')
      except IOError as e:
        parent._print(f"IO error updating pyproject.toml: {e}", 'error')
      except re.error as e:
        parent._print(f"Regex error updating version in pyproject.toml: {e}", 'error')

      return False

    def _create_git_tag(self, version: str, message: str) -> bool:
      """Create and push git tag."""
      parent = self.parent
      tag = f"v{version}"

      result = parent._run_command(
        ['git', 'tag', '-a', tag, '-m', message, 'HEAD'],
        capture_output=True
      )

      if isinstance(result, subprocess.CompletedProcess) and result.returncode == 0:
        parent._print(f"Created tag {tag} on HEAD", 'success')
        return True

      error_msg = result.stderr if hasattr(result, 'stderr') and result.stderr else "Unknown error"
      parent._print(f"Failed to create tag: {error_msg}", 'error')
      return False

    def autotag(self, version: Optional[str] = None, auto_increment: bool = True) -> None:
      """Create git tag with Claude-generated message, auto-incrementing version if needed."""
      parent = self.parent
      parent._print(f"ðŸ·ï¸  Creating {parent.project_name} version tag...", 'info')

      # Validate we're in a git repository
      result = parent._run_command(['git', 'rev-parse', '--git-dir'], capture_output=True)
      if not (isinstance(result, subprocess.CompletedProcess) and result.returncode == 0):
        parent._print("Not in a git repository", 'error')
        return

      # Determine version to use
      final_version = version

      if version is None and auto_increment:
        latest_tag = self._get_current_version()
        if latest_tag:
          parent._print(f"Latest tag: {latest_tag}", 'info')
          final_version = self._increment_version(latest_tag)
          if final_version:
            parent._print(f"Auto-incrementing to: {final_version}", 'info')
          else:
            parent._print(f"Invalid version format: {latest_tag} (expected X.Y.Z)", 'error')
        else:
          parent._print("No existing tags found. Please provide a version manually.", 'error')

      if final_version is None:
        parent._print("No version provided and auto-increment disabled", 'error')
        return

      # Clean and validate version
      final_version = final_version.lstrip('v')

      if not self._validate_version_format(final_version):
        parent._print(f"Invalid version format: {final_version} (expected X.Y.Z)", 'error')
        return

      # Check if tag already exists
      tag = f"v{final_version}"
      result = parent._run_command(['git', 'rev-parse', tag], capture_output=True)
      if isinstance(result, subprocess.CompletedProcess) and result.returncode == 0:
        parent._print(f"Tag '{tag}' already exists", 'error')
        return

      # Check if the version in the committed state is already at the target
      committed_version = self._get_committed_version()
      version_already_committed = committed_version == final_version

      if version_already_committed:
        parent._print(f"Version in HEAD is already {final_version}, skipping commit step", 'info')
      else:
        # Update version in pyproject.toml
        parent._print(f"ðŸ“ Updating version in pyproject.toml to {final_version}...", 'info')
        if not self._update_pyproject_version(final_version):
          return

        # Commit the version change
        parent._print("ðŸ’¾ Committing version update...", 'info')
        if not parent._run_command(['git', 'add', 'pyproject.toml'], "Staging pyproject.toml"):
          parent._print("Failed to stage pyproject.toml", 'error')
          return

        commit_msg = f"Bump version to {final_version}"
        if not parent._run_command(['git', 'commit', '-m', commit_msg], f"Committing version bump"):
          parent._print("Failed to commit version change", 'error')
          return

      # Generate tag message with Claude
      parent._print("ðŸ¤– Generating tag message with Claude...", 'info')
      result = parent._run_command(
        ['poetry', 'run', 'claude', '-p',
         'You must output ONLY a short tag message. NO analysis, NO explanations, NO preamble. Just a brief description for the git tag based on the most recent commit. Do NOT mention Claude, AI, phases, or any automated tools. Output only the tag description itself (e.g., "Add user authentication feature" or "Fix database connection bug").'],
        capture_output=True
      )

      tag_message = None
      if isinstance(result, subprocess.CompletedProcess) and result.returncode == 0:
        tag_message = result.stdout.strip()
        parent._print(f"Tag message: {tag_message}", 'info')
      else:
        parent._print("Failed to generate tag message with Claude", 'error')
        return

      # Create the tag
      parent._print(f"Creating tag: {tag}", 'info')
      if not self._create_git_tag(final_version, tag_message):
        return

      # Push commit and tag to remote
      parent._print("ðŸš€ Pushing commit and tag to remote...", 'info')
      push_success = parent._run_command(['git', 'push'], "Pushing commit to remote")
      if push_success:
        push_success = parent._run_command(['git', 'push', 'origin', tag], f"Pushing tag {tag} to remote")

      if push_success:
        parent._print("ðŸŽ‰ Version updated, tagged, and pushed successfully!", 'success')
        parent._print(f"Version: {final_version}", 'success')
        parent._print(f"Tag: {tag}", 'success')
        parent._print("Pushed to remote repository", 'success')
      else:
        parent._print("Failed to push to remote. Commit and tag created locally.", 'error')
        parent._print(f"To push manually, run: {parent.colors['blue']}git push && git push --tags{parent.colors['nc']}",
                      'info')
      return

    def analyze_deps(
        self,
        output_format: str = "console",
        output_file: str | None = None,
        filter_package: str | None = None,
        include_external: bool = False,
        show_classes: bool = True,
        show_cycles: bool = True,
        max_depth: int = 10
    ) -> None:
      """
      Analyze project dependencies and optionally generate diagrams.

      Performs AST-based analysis to extract imports, class hierarchies, and package relationships.

      :param output_format: Output format - 'console', 'json', or 'diagram'
      :param output_file: Optional output file path (defaults based on format)
      :param filter_package: Filter to specific package (e.g., 'freyja.cli')
      :param include_external: Include external (non-project) dependencies
      :param show_classes: Include class-level dependency analysis
      :param show_cycles: Detect and report circular dependencies
      :param max_depth: Maximum depth for dependency traversal
      """
      parent = self.parent
      parent._print(f"ðŸ” Analyzing {parent.project_name} dependencies...", 'info')

      # Import the analyzer and formatters (at method level to avoid circular deps)
      import sys


      sys.path.insert(0, '.')
      from freyja.utils.dependency_analyzer import DependencyAnalyzer
      from freyja.utils.console_formatter import ConsoleFormatter
      from freyja.utils.json_formatter import JsonFormatter


      # Create analyzer instance
      analyzer = DependencyAnalyzer(
        project_path=Path(parent.project_src),
        include_external=include_external,
        max_depth=max_depth
      )

      # Run analysis
      parent._print("ðŸ“Š Running AST analysis...", 'info')
      raw_analysis = analyzer.analyze()

      # Extract dependencies
      package_deps = analyzer.extract_package_dependencies(raw_analysis)
      class_deps = analyzer.extract_class_dependencies(raw_analysis)

      # Filter if requested
      if filter_package:
        parent._print(f"ðŸ” Filtering to package: {filter_package}", 'info')
        raw_analysis = analyzer.filter_results(raw_analysis, filter_package)
        package_deps = {k: v for k, v in package_deps.items() if k.startswith(filter_package)}
        class_deps = {k: v for k, v in class_deps.items() if k.startswith(filter_package)}

      # Detect cycles if requested
      cycles = []
      if show_cycles:
        parent._print("ðŸ”„ Detecting circular dependencies...", 'info')
        cycles = analyzer.detect_cycles(package_deps)
        if cycles:
          parent._print(f"âš ï¸ Found {len(cycles)} circular dependencies!", 'warning')

      # Prepare analysis result
      analysis_result = {
        'raw_analysis': raw_analysis,
        'package_dependencies': package_deps,
        'class_dependencies': class_deps,
        'cycles': cycles,
        'metadata': {
          'project_name': parent.project_name,
          'total_modules': len(raw_analysis),
          'total_packages': len(set(k.split('.')[1] if '.' in k else k for k in package_deps.keys())),
          'total_classes': len(class_deps)
        }
      }

      # Format output
      formatter = None
      if output_format == "console":
        formatter = ConsoleFormatter(
          show_classes=show_classes,
          show_cycles=show_cycles,
          colors=parent.colors
        )
      elif output_format == "json":
        formatter = JsonFormatter(pretty=True)
      elif output_format == "diagram":
        parent._print("Diagram generation not yet implemented", 'error')
        return
      else:
        parent._print(f"Unknown output format: {output_format}", 'error')
        return

      # Generate output
      formatted_output = formatter.format(analysis_result)

      # Write output
      if output_file:
        with open(output_file, 'w') as f:
          f.write(formatted_output)
        parent._print(f"âœ… Analysis saved to {output_file}", 'success')
      else:
        print(formatted_output)

      # Print summary
      metadata = analysis_result['metadata']
      parent._print(f"ðŸ“ˆ Analysis complete: {metadata['total_modules']} modules, "
                    f"{metadata['total_packages']} packages, {metadata['total_classes']} classes", 'success')
      return

  class Quality:
    """Code quality, linting, diagnostics, and completion operations."""

    def __init__(self, parent) -> None:
      """Initialize with parent FreyjaDevTools instance."""
      self.parent: 'FreyjaDevTools' = parent

    def lint(self, fix: bool = False, skip_mypy: bool = False) -> None:
      """
      Run all linting and formatting tools, optionally auto-fixing issues.

      :param fix: Auto-fix linting issues where possible
      :param skip_mypy: Skip MyPy type checking if True
      """
      parent = self.parent
      parent._print("ðŸ” Running code quality checks...", 'info')

      success: bool = True

      # Big bright message before linting
      print(f"\n{parent.colors['yellow']}{'=' * 60}{parent.colors['nc']}")
      print(f"{parent.colors['yellow']}{'=' * 20} ðŸ” LINTING... {'=' * 20}{parent.colors['nc']}")
      print(f"{parent.colors['yellow']}{'=' * 60}{parent.colors['nc']}\n")

      # Run Ruff formatting first (establishes base code style)
      ruff_format_cmd = "poetry run ruff format ."
      if not fix:
        ruff_format_cmd += " --check"
      if not parent._run_command(ruff_format_cmd, "ðŸŽ¨ Running Ruff formatting..."):
        success = False

      # Run Ruff linting second (checks logical issues on formatted code)
      ruff_cmd = "poetry run ruff check ."
      if fix:
        ruff_cmd += " --fix"
      if not parent._run_command(ruff_cmd, "ðŸ“ Running Ruff linting..."):
        success = False

      # Run MyPy with strict type checking (unless skipped)
      if not skip_mypy:
        # Big bright message before MyPy
        print(f"\n{parent.colors['blue']}{'=' * 60}{parent.colors['nc']}")
        print(f"{parent.colors['blue']}{'=' * 18} ðŸ”§ RUNNING MYPY {'=' * 18}{parent.colors['nc']}")
        print(f"{parent.colors['blue']}{'=' * 60}{parent.colors['nc']}\n")

        # Use actual package name instead of git repo name
        package_name = parent.project_src  # The actual Python package name
        mypy_cmd = f"poetry run mypy {package_name}"
        # Generate reports if directories exist
        reports_dir = Path(parent.project_src) / "reports" / "mypy"
        if reports_dir.exists():
          mypy_cmd += f" --html-report {reports_dir} --linecount-report {reports_dir} --linecoverage-report {reports_dir}"
        if not parent._run_command(mypy_cmd, "ðŸ”§ Running MyPy type checking..."):
          success = False
      else:
        parent._print("â­ï¸  Skipping MyPy type checking (--skip-mypy)", 'info')

      if success:
        parent._print("All code quality checks passed!", 'success')
        sys.exit(0)
      else:
        parent._print("Some code quality checks failed!", 'error')
        sys.exit(1)

    def completion(self, examples_only: bool = False) -> None:
      """Test shell completion functionality, optionally just examples."""
      parent = self.parent
      parent._print("ðŸ”§ Testing shell completion functionality...", 'info')

      # Set up environment
      os.environ['PYTHONPATH'] = str(parent.project_src)
      os.chdir(parent.project_src)

      tests_passed: int = 0
      tests_failed: int = 0
      critical_failures: int = 0

      def run_completion_test(test_name: str, test_command: str, expected_pattern: str, critical: bool = False) -> bool:
        nonlocal tests_passed, tests_failed, critical_failures

        test_result: bool = False

        if parent.verbose:
          print(f"Running test: {test_name}")
          print(f"Command: {test_command}")

        result = parent._run_command(shlex.split(test_command), capture_output=True, timeout=10)

        if isinstance(result, subprocess.CompletedProcess):
          if result.returncode == 0 and (expected_pattern in result.stdout or expected_pattern in result.stderr):
            if parent.verbose:
              parent._print(f"âœ… {test_name}", 'success')
            tests_passed += 1
            test_result = True
          else:
            parent._print(f"âŒ {test_name}", 'error')
            if parent.verbose:
              print(f"Expected pattern: {expected_pattern}")
              if hasattr(result, 'stdout'):
                print(f"Stdout: {result.stdout[:200]}")
              if hasattr(result, 'stderr'):
                print(f"Stderr: {result.stderr[:200]}")
            tests_failed += 1
            if critical:
              critical_failures += 1
        else:
          # Timeout or other error
          parent._print(f"â° {test_name} - TIMEOUT or ERROR", 'error')
          tests_failed += 1
          if critical:
            critical_failures += 1

        return test_result

      # Test basic completion functionality
      if not examples_only:
        parent._print("Testing basic completion system...", 'info')

        # Test help completion
        run_completion_test(
          "Help completion",
          "python examples/cls_example --help",
          "usage:",
          critical=True
        )

        # Test command completion
        run_completion_test(
          "Command completion",
          "python examples/cls_example completion install",
          "completion",
          critical=False
        )

      # Test examples completion
      parent._print("Testing examples completion...", 'info')

      # Test cls_example basic functionality
      run_completion_test(
        "cls_example help",
        "python examples/cls_example --help",
        "usage:",
        critical=True
      )

      # Test cls_example command execution
      run_completion_test(
        "cls_example command execution",
        "python examples/cls_example file-operations--process-single --input-file test.txt --dry-run",
        "test.txt",
        critical=False
      )

      # Test multi-class example
      run_completion_test(
        "multi_class_example help",
        "python examples/multi_class_example --help",
        "usage:",
        critical=False
      )

      # Print results
      total_tests: int = tests_passed + tests_failed
      parent._print(f"Completion test results: {tests_passed}/{total_tests} passed", 'info')

      if critical_failures > 0:
        parent._print(f"âŒ {critical_failures} critical failures detected!", 'error')
      elif tests_failed > 0:
        parent._print(f"âš ï¸  {tests_failed} non-critical tests failed", 'warning')
      else:
        parent._print("All completion tests passed!", 'success')
      return

    def diagnose(self, include_env: bool = True, include_completion: bool = True) -> None:
      """Run comprehensive diagnostic analysis for development issues."""
      parent = self.parent
      parent._print("ðŸ” Running comprehensive diagnostic analysis...", 'info')

      if include_env:
        parent._print("=== Environment Variable Analysis ===", 'info')
        print(f"Current shell: {os.environ.get('SHELL', 'Unknown')}")
        print(f"Current PID: {os.getpid()}")
        print()

        # Check project-related environment variables
        project_vars: Dict[str, str] = {k: v for k, v in os.environ.items() if
                                        parent.project_name.lower() in k.lower() or 'comp_' in k.lower()}
        if project_vars:
          print(f"{parent.project_name.capitalize()} completion environment variables:")
          for k, v in project_vars.items():
            print(f"  {k}={v}")
        else:
          print(f"No {parent.project_name.capitalize()} completion environment variables found")
        print()

      if include_completion:
        parent._print("=== Completion System Analysis ===", 'info')

        # Test completion system availability
        result = parent._run_command(
          ['python', 'examples/cls_example', 'completion', '--help'],
          capture_output=True,
          timeout=5
        )
        if isinstance(result, subprocess.CompletedProcess) and result.returncode == 0:
          parent._print("Completion system is available", 'success')
        else:
          parent._print("Completion system unavailable or broken", 'error')

        # Test shell-specific completion
        shell: str = os.environ.get('SHELL', '')
        if 'bash' in shell:
          parent._run_command(f"complete -p | grep -i {parent.project_name} || echo 'No bash completion found'",
                              "Bash completion status:")
        elif 'zsh' in shell:
          parent._run_command(f"compdef | grep -i {parent.project_name} || echo 'No zsh completion found'",
                              "Zsh completion status:")

        print()

      # Python environment check
      parent._print("=== Python Environment ===", 'info')
      parent._run_command("poetry run python --version", "Python version:")
      parent._run_command(
        f"poetry run python -c 'import {parent.project_name}; print(f\"{parent.project_name.capitalize()} module: {{{parent.project_name}.__file__}}\")'",
        f"{parent.project_name.capitalize()} module location:")

      # Project structure check
      parent._print("=== Project Structure ===", 'info')
      important_files: List[str] = [
        "pyproject.toml",
        f"{parent.project_name}/__init__.py",
        "examples/cls_example",
        "examples/multi_class_example"
      ]

      for file_path in important_files:
        full_path: Path = Path(parent.project_src) / file_path
        if full_path.exists():
          parent._print(f"âœ… {file_path} exists", 'success')
        else:
          parent._print(f"âŒ {file_path} missing", 'error')

      parent._print("Diagnostic analysis complete!", 'success')
      return

  class Test:
    """Testing operations."""

    def __init__(self, parent, pattern: str = "", coverage: bool = True, parallel: bool = False,
                 verbose: bool = False) -> None:
      """Initialize with parent and test configuration options."""
      self.parent: 'FreyjaDevTools' = parent
      self.coverage: bool = coverage
      self.parallel: bool = parallel
      self.pattern: str = pattern
      self.verbose: bool = verbose

    def _build_test_cmd(self, test_mark: str) -> List[str]:
      """Build pytest command with common options and specified test mark."""
      parent = self.parent
      cmd_parts: List[str] = ["poetry", "run", "pytest"]

      if self.coverage:
        cmd_parts.extend([f"--cov={parent.project_name}", "--cov-report=term-missing", "--cov-report=html"])

      if self.verbose:
        cmd_parts.append("-sv")

      if self.parallel:
        cmd_parts.append("-n auto")

      cmd_parts.extend(["-m", test_mark])

      if self.pattern:
        cmd_parts.extend(["-k", self.pattern])

      return cmd_parts

    def unit(self, ) -> None:
      """Run unit tests with configured options."""
      parent = self.parent
      parent._print("ðŸ§ª Running unit tests with coverage...", 'info')

      cmd_parts = self._build_test_cmd("unit")
      success = parent._run_command(cmd_parts)

      if success:
        parent._print("ðŸ“Š Coverage report generated in htmlcov/", 'info')
        parent._print("Unit tests completed successfully!", 'success')
      else:
        parent._print("Unit tests failed!", 'error')
      return

    def integration(self) -> None:
      """Run integration tests with configured options."""
      parent = self.parent
      parent._print("ðŸ”— Running integration tests...", 'info')

      cmd_parts = self._build_test_cmd("integration")
      success = parent._run_command(cmd_parts)

      if success:
        parent._print("ðŸ“Š Coverage report generated in htmlcov/", 'info')
        parent._print("Integration tests completed successfully!", 'success')
      else:
        parent._print("Integration tests failed!", 'error')
      return

    def all(self) -> None:
      """Run all tests (unit and integration) with configured options."""
      parent = self.parent
      parent._print("ðŸ§ª Running all tests (unit and integration)...", 'info')

      cmd_parts = self._build_test_cmd("unit or integration")
      success = parent._run_command(cmd_parts)

      if success:
        parent._print("ðŸ“Š Coverage report generated in htmlcov/", 'info')
        parent._print("All tests completed successfully!", 'success')
      else:
        parent._print("Some tests failed!", 'error')
      return


if __name__ == '__main__':
  # Create the CLI instance and store reference for inner classes
  # sys.modules[__name__].__dict__['_parent_instance'] = FreyjaDevTools()

  cli = FreyjaCLI(FreyjaDevTools, title=f"{FreyjaDevTools.get_project_name().capitalize()} Development Tools")
  result = cli.run()
  sys.exit(result if isinstance(result, int) else 0)
