#!/usr/bin/env python3
"""
Development Tools CLI
Consolidates all development scripts into a single FreyjaCLI implementation.
"""
import os
import sys
import subprocess
import shutil
import glob
import re
from pathlib import Path
from typing import Optional, List
from freyja import FreyjaCLI

# Add the project root to the Python path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

# Detect project name from git repository
try:
  PROJECT_NAME = subprocess.run(
    "basename $(git rev-parse --show-toplevel)",
    shell=True,
    capture_output=True,
    text=True,
    check=True
  ).stdout.strip()
except subprocess.CalledProcessError:
  PROJECT_NAME = "project"  # Fallback if not in git repo



class FreyjaDevTools:
  """
  Development Tools - Comprehensive development utilities.

  A complete development toolkit using Freyja's inner class pattern to organize
  build, test, and development setup commands.
  """

  def __init__(self, verbose: bool = False, dry_run: bool = False):
    """
    Initialize development tools.

    :param verbose: Enable verbose output for all operations
    :param dry_run: Show commands that would be run without executing them
    """
    self.verbose = verbose
    self.dry_run = dry_run
    self.project_root = project_root
    self.project_name = PROJECT_NAME
    self.colors = {
      'red': '\033[0;31m',
      'green': '\033[0;32m',
      'yellow': '\033[1;33m',
      'blue': '\033[0;34m',
      'nc': '\033[0m'  # No Color
    }

  def _run_command(self, command: str, description: str = "", shell: bool = True) -> bool:
    """
    Execute a shell command with proper logging.

    :param command: Command to execute
    :param description: Description of the command for output
    :param shell: Whether to run in shell mode
    :return: True if command succeeded, False otherwise
    """
    if description:
      print(f"{self.colors['blue']}{description}{self.colors['nc']}")

    if self.verbose or self.dry_run:
      print(f"Command: {command}")

    if self.dry_run:
      print("(DRY RUN - command not executed)")
      return True

    try:
      result = subprocess.run(command, shell=shell, check=True, cwd=self.project_root)
      return result.returncode == 0
    except subprocess.CalledProcessError as e:
      print(f"{self.colors['red']}‚ùå Command failed with exit code {e.returncode}{self.colors['nc']}")
      return False

  def _print_success(self, message: str) -> None:
    """Print success message with formatting."""
    print(f"{self.colors['green']}‚úÖ {message}{self.colors['nc']}")

  def _print_error(self, message: str) -> None:
    """Print error message with formatting."""
    print(f"{self.colors['red']}‚ùå {message}{self.colors['nc']}")

  def _print_info(self, message: str) -> None:
    """Print info message with formatting."""
    print(f"{self.colors['blue']}‚ÑπÔ∏è  {message}{self.colors['nc']}")

  class Setup:
    """Development environment and self-installation setup operations."""

    def __init__(self, parent):
      """Initialize setup operations.

      :param parent: Parent FreyjaDevTools instance
      """
      self.parent = parent

    def env(self) -> None:
      """Set up the development environment with dependencies and pre-commit hooks."""
      parent = self.parent
      print(f"{parent.colors['blue']}üöÄ Setting up development environment for {parent.project_name}...{parent.colors['nc']}")

      # Install dependencies
      if not parent._run_command("poetry install --with dev", "üì¶ Installing dependencies with Poetry..."):
        parent._print_error("Failed to install dependencies")
        return

      # Install pre-commit hooks
      if not parent._run_command("poetry run pre-commit install", "ü™ù Installing pre-commit hooks..."):
        parent._print_error("Failed to install pre-commit hooks")
        return

      # Verify Python version
      parent._run_command("poetry run python --version", "üêç Python version:")

      parent._print_success("Development environment setup complete!")
      print()
      print("Available commands:")
      print("  python bin/dev-tools build compile     # Compile/build package")
      print("  python bin/dev-tools build lint        # Run linters")
      print("  python bin/dev-tools test run          # Run tests")
      print("  python bin/dev-tools build tag-version    # Create git tag for HEAD commit")
      print("  python bin/dev-tools build publish     # Publish to PyPI")

    def self(self, force: bool = False) -> None:
      """
      Compile and install the latest version from dist/.

      :param force: Force reinstallation even if version hasn't changed
      """
      parent = self.parent
      parent._print_info(f"üîß Building and installing latest {parent.project_name} version...")

      # First, build the package
      parent._print_info("Building package first...")
      if not parent._run_command("poetry build", "üî® Building package..."):
        parent._print_error("Build failed!")
        return

      # Find the latest wheel file
      dist_dir = parent.project_root / "dist"
      if not dist_dir.exists():
        parent._print_error("dist/ directory not found. Run build first.")
        return

      wheel_files = list(dist_dir.glob("*.whl"))
      if not wheel_files:
        parent._print_error("No wheel files found in dist/. Build may have failed.")
        return

      # Get the latest wheel file (by modification time)
      latest_wheel = max(wheel_files, key=lambda p: p.stat().st_mtime)
      parent._print_info(f"Installing wheel: {latest_wheel.name}")

      # Install the wheel
      install_cmd = f"pip install {latest_wheel}"
      if force:
        install_cmd += " --force-reinstall"

      if not parent._run_command(install_cmd, f"üì¶ Installing {latest_wheel.name}..."):
        parent._print_error("Installation failed!")
        return

      # Verify installation
      parent._run_command(
        f"python -c 'import {parent.project_name}; print(f\"{parent.project_name.capitalize()} version: {{{parent.project_name}.__version__ if hasattr({parent.project_name}, \"__version__\") else \"unknown\"}}\"); print(f\"{parent.project_name.capitalize()} location: {{{parent.project_name}.__file__}}\")'",
        "üîç Verifying installation:"
      )

      parent._print_success("Self-installation complete!")
      parent._print_info(f"You can now use '{parent.project_name}' from anywhere on your system")


  class Build:
    """Build, compilation, and publishing operations."""

    def __init__(self, parent, parallel: bool = True):
      """
      Initialize build operations.

      :param parent: Parent FreyjaDevTools instance
      :param parallel: Enable parallel execution where possible
      """
      self.parent = parent
      self.parallel = parallel

    def clean(self) -> None:
      """Clean build artifacts, cache files, and temporary files."""
      parent = self.parent
      parent._print_info("üßπ Cleaning build artifacts and cache files...")

      # Patterns to clean
      patterns_to_remove = [
        "**/*.pyc",
        "**/__pycache__",
        "**/.ipynb_checkpoints",
        "**/.pytest_cache",
        "build",
        "dist",
        "*.egg-info"
      ]

      removed_count = 0
      for pattern in patterns_to_remove:
        for path in glob.glob(pattern, recursive=True):
          path_obj = Path(path)
          try:
            if path_obj.is_dir():
              if not parent.dry_run:
                shutil.rmtree(path_obj)
              if parent.verbose or parent.dry_run:
                print(f"Removed directory: {path}")
              removed_count += 1
            elif path_obj.is_file():
              if not parent.dry_run:
                path_obj.unlink()
              if parent.verbose or parent.dry_run:
                print(f"Removed file: {path}")
              removed_count += 1
          except Exception as e:
            parent._print_error(f"Failed to remove {path}: {e}")

      if removed_count > 0:
        parent._print_success(f"Cleaned {removed_count} items")
      else:
        parent._print_info("No items to clean")

    def lint(self, fix: bool = False) -> None:
      """
      Run all linting and formatting tools.

      :param fix: Automatically fix issues where possible
      """
      parent = self.parent
      parent._print_info("üîç Running code quality checks...")

      success = True

      # Run Ruff
      ruff_cmd = "poetry run ruff check ."
      if fix:
        ruff_cmd += " --fix"
      if not parent._run_command(ruff_cmd, "üìù Running Ruff..."):
        success = False

      # Run Black
      black_cmd = "poetry run black ."
      if not fix:
        black_cmd += " --check"
      if not parent._run_command(black_cmd, "‚ö´ Running Black..."):
        success = False

      # Run MyPy
      if not parent._run_command(f"poetry run mypy {parent.project_name} --ignore-missing-imports", "üîß Running MyPy..."):
        success = False

      # Run Pylint
      if not parent._run_command(f"poetry run pylint {parent.project_name}", "üêç Running Pylint..."):
        success = False

      if success:
        parent._print_success("All code quality checks passed!")
      else:
        parent._print_error("Some code quality checks failed!")

    def compile(self, clean_first: bool = True) -> None:
      """
      Compile/build the package using Poetry.

      :param clean_first: Clean build artifacts before building
      """
      parent = self.parent

      if clean_first:
        self.clean()

      parent._print_info("üî® Building package with Poetry...")

      if not parent._run_command("poetry build", "Building package..."):
        parent._print_error("Build failed!")
        return

      # Show build info
      parent._run_command("ls -la dist/", "üìã Build information:")
      parent._print_success("Package built successfully!")

    def publish(self, test_pypi: bool = False) -> None:
      """
      Build and publish package to PyPI.

      :param test_pypi: Publish to test PyPI instead of production
      """
      parent = self.parent
      parent._print_info(f"üì¶ Building and publishing {parent.project_name} to PyPI...")

      # Clean and build first
      self.compile(clean_first=True)

      # Check for PyPI token
      token_var = "TEST_PYPI_TOKEN" if test_pypi else "PYPI_TOKEN"
      if not os.environ.get(token_var):
        parent._print_error(f"{token_var} environment variable not set")
        parent._print_error(f"Please set {token_var} environment variable with your PyPI token")
        return

      parent._print_info("üîê Configuring PyPI authentication...")

      # Configure repositories
      if test_pypi:
        repo_url = "https://test.pypi.org/legacy/"
        parent._run_command(f"poetry config repositories.testpypi {repo_url}")
        parent._run_command(f"poetry config http-basic.testpypi __token__ {os.environ[token_var]}")
        publish_cmd = "poetry publish -r testpypi"
      else:
        parent._run_command("poetry config repositories.pypi https://upload.pypi.org/legacy/")
        parent._run_command(f"poetry config http-basic.pypi __token__ {os.environ[token_var]}")
        publish_cmd = "poetry publish"

      # Publish
      if not parent._run_command(publish_cmd, "üöÄ Publishing to PyPI..."):
        parent._print_error("Publishing failed!")
        return

      if test_pypi:
        parent._print_success(f"Published successfully to https://test.pypi.org/project/{parent.project_name}/")
        parent._print_info(f"Install with: pip install --index-url https://test.pypi.org/simple/ {parent.project_name}")
      else:
        parent._print_success(f"Published successfully to https://pypi.org/project/{parent.project_name}/")
        parent._print_info(f"Install with: pip install {parent.project_name}")

    def tag_version(self, version: Optional[str] = None, auto_increment: bool = True) -> None:
      """
      Create git tag for the current HEAD commit using Claude to generate message.

      :param version: Specific version to tag (e.g., "1.0.5"). If not provided, auto-increments patch version
      :param auto_increment: Whether to auto-increment from latest tag when version not provided (default: True)
      """
      parent = self.parent
      parent._print_info(f"üè∑Ô∏è  Creating {parent.project_name} version tag...")

      # Validate we're in a git repository
      try:
        subprocess.run("git rev-parse --git-dir", shell=True, capture_output=True, text=True, check=True)
      except subprocess.CalledProcessError:
        parent._print_error("Not in a git repository")
        return

      # Determine version to use
      if version is None and auto_increment:
        # Get latest tag and auto-increment
        try:
          result = subprocess.run("git describe --tags --abbrev=0", shell=True, capture_output=True, text=True, check=True)
          latest_tag = result.stdout.strip()
          parent._print_info(f"Latest tag: {latest_tag}")

          # Remove 'v' prefix if present and increment patch version
          version_num = latest_tag.lstrip('v')

          # Validate and parse version
          version_match = re.match(r'^(\d+)\.(\d+)\.(\d+)$', version_num)
          if not version_match:
            parent._print_error(f"Invalid version format: {version_num} (expected X.Y.Z)")
            return

          major, minor, patch = map(int, version_match.groups())
          patch += 1
          version = f"{major}.{minor}.{patch}"
          parent._print_info(f"Auto-incrementing to: {version}")

        except subprocess.CalledProcessError:
          parent._print_error("No existing tags found. Please provide a version manually.")
          return

      if version is None:
        parent._print_error("No version provided and auto-increment disabled")
        return

      # Remove 'v' prefix if user provided it
      version = version.lstrip('v')

      # Validate version format
      if not re.match(r'^\d+\.\d+\.\d+$', version):
        parent._print_error(f"Invalid version format: {version} (expected X.Y.Z)")
        return

      # Check if tag already exists
      tag = f"v{version}"
      try:
        subprocess.run(f"git rev-parse {tag}", shell=True, capture_output=True, check=True)
        parent._print_error(f"Tag '{tag}' already exists")
        return
      except subprocess.CalledProcessError:
        # Tag doesn't exist, which is what we want
        pass

      # Update version in pyproject.toml
      parent._print_info(f"üìù Updating version in pyproject.toml to {version}...")
      pyproject_path = parent.project_root / "pyproject.toml"

      try:
        with open(pyproject_path, 'r') as f:
          content = f.read()

        # Update version line
        updated_content = re.sub(
          r'^version = "[^"]+"',
          f'version = "{version}"',
          content,
          count=1,
          flags=re.MULTILINE
        )

        with open(pyproject_path, 'w') as f:
          f.write(updated_content)

        parent._print_success(f"Updated pyproject.toml version to {version}")
      except Exception as e:
        parent._print_error(f"Failed to update pyproject.toml: {e}")
        return

      # Commit the version change
      parent._print_info("üíæ Committing version update...")
      if not parent._run_command("git add pyproject.toml", "Staging pyproject.toml"):
        parent._print_error("Failed to stage pyproject.toml")
        return

      commit_msg = f"Bump version to {version}"
      commit_cmd = f'''git commit -m "$(cat <<'EOF'
{commit_msg}
EOF
)"'''
      if not parent._run_command(commit_cmd, f"Committing version bump"):
        parent._print_error("Failed to commit version change")
        return

      # Use Claude to generate tag message
      parent._print_info("ü§ñ Generating tag message with Claude...")
      try:
        result = subprocess.run(
          'claude -p "Create a very short message to be used on a new tag basing it on the most recent commit (HEAD). Return a single string representing the tag description with no preamble, summary, or afterthoughts."',
          shell=True,
          capture_output=True,
          text=True,
          check=True
        )
        tag_message = result.stdout.strip()
        parent._print_info(f"Tag message: {tag_message}")
      except subprocess.CalledProcessError:
        parent._print_error("Failed to generate tag message with Claude")
        return

      # Create the tag on HEAD
      parent._print_info(f"Creating tag: {tag}")

      # Use subprocess directly to handle multi-line tag messages properly
      try:
        subprocess.run(
          ['git', 'tag', '-a', tag, 'HEAD', '-m', tag_message],
          cwd=parent.project_root,
          capture_output=True,
          text=True,
          check=True
        )
        parent._print_success(f"Created tag {tag} on HEAD")
      except subprocess.CalledProcessError as e:
        parent._print_error(f"Failed to create tag: {e.stderr}")
        return

      # Push commit and tag to remote
      parent._print_info("üöÄ Pushing commit and tag to remote...")
      if not parent._run_command("git push && git push --tags", "Pushing to remote"):
        parent._print_error("Failed to push to remote. Commit and tag created locally.")
        parent._print_info(f"To push manually, run: {parent.colors['blue']}git push && git push --tags{parent.colors['nc']}")
        return

      # Success summary
      parent._print_success("üéâ Version updated, tagged, and pushed successfully!")
      parent._print_success(f"Version: {version}")
      parent._print_success(f"Tag: {tag}")
      parent._print_success("Pushed to remote repository")


  class Test:
    """Testing, diagnostics, and quality assurance operations."""

    def __init__(self, parent, coverage: bool = True):
      """
      Initialize test operations.

      :param parent: Parent FreyjaDevTools instance
      :param coverage: Enable coverage reporting by default
      """
      self.parent = parent
      self.coverage = coverage

    def run(self, pattern: str = "", parallel: bool = False, verbose_output: bool = False) -> None:
      """
      Run the test suite with coverage reporting.

      :param pattern: Pattern to filter tests (e.g., "test_cli")
      :param parallel: Run tests in parallel (requires pytest-xdist)
      :param verbose_output: Enable verbose test output
      """
      parent = self.parent
      parent._print_info("üß™ Running tests with coverage...")

      # Build test command
      cmd_parts = ["poetry run pytest"]

      if self.coverage:
        cmd_parts.extend([f"--cov={parent.project_name}", "--cov-report=term-missing", "--cov-report=html"])

      if verbose_output:
        cmd_parts.append("-v")

      if parallel:
        cmd_parts.append("-n auto")

      if pattern:
        cmd_parts.append(f"-k {pattern}")

      test_command = " ".join(cmd_parts)

      if not parent._run_command(test_command):
        parent._print_error("Tests failed!")
        return

      parent._print_info("üìä Coverage report generated in htmlcov/")
      parent._print_success("Tests completed successfully!")

    def completion(self, examples_only: bool = False) -> None:
      """
      Test shell completion functionality comprehensively.

      :param examples_only: Only test example completion, not full suite
      """
      parent = self.parent
      parent._print_info("üîß Testing shell completion functionality...")

      # Set up environment
      os.environ['PYTHONPATH'] = str(parent.project_root)
      os.chdir(parent.project_root)

      tests_passed = 0
      tests_failed = 0
      critical_failures = 0

      def run_completion_test(test_name: str, test_command: str, expected_pattern: str, critical: bool = False) -> bool:
        nonlocal tests_passed, tests_failed, critical_failures

        if parent.verbose:
          print(f"Running test: {test_name}")
          print(f"Command: {test_command}")

        try:
          result = subprocess.run(test_command, shell=True, capture_output=True, text=True, timeout=10)

          if expected_pattern in result.stdout or expected_pattern in result.stderr:
            if parent.verbose:
              parent._print_success(f"‚úÖ {test_name}")
            tests_passed += 1
            return True
          else:
            parent._print_error(f"‚ùå {test_name}")
            if parent.verbose:
              print(f"Expected pattern: {expected_pattern}")
              print(f"Stdout: {result.stdout[:200]}")
              print(f"Stderr: {result.stderr[:200]}")
            tests_failed += 1
            if critical:
              critical_failures += 1
            return False

        except subprocess.TimeoutExpired:
          parent._print_error(f"‚è∞ {test_name} - TIMEOUT")
          tests_failed += 1
          if critical:
            critical_failures += 1
          return False
        except Exception as e:
          parent._print_error(f"üí• {test_name} - ERROR: {e}")
          tests_failed += 1
          if critical:
            critical_failures += 1
          return False

      # Test basic completion functionality
      if not examples_only:
        parent._print_info("Testing basic completion system...")

        # Test help completion
        run_completion_test(
          "Help completion",
          "python examples/cls_example --help",
          "usage:",
          critical=True
        )

        # Test command completion
        run_completion_test(
          "Command completion",
          "python examples/cls_example completion install",
          "completion",
          critical=False
        )

      # Test examples completion
      parent._print_info("Testing examples completion...")

      # Test cls_example basic functionality
      run_completion_test(
        "cls_example help",
        "python examples/cls_example --help",
        "usage:",
        critical=True
      )

      # Test cls_example command execution
      run_completion_test(
        "cls_example command execution",
        "python examples/cls_example file-operations--process-single --input-file test.txt --dry-run",
        "test.txt",
        critical=False
      )

      # Test multi-class example
      run_completion_test(
        "multi_class_example help",
        "python examples/multi_class_example --help",
        "usage:",
        critical=False
      )

      # Print results
      total_tests = tests_passed + tests_failed
      parent._print_info(f"Completion test results: {tests_passed}/{total_tests} passed")

      if critical_failures > 0:
        parent._print_error(f"‚ùå {critical_failures} critical failures detected!")
        return

      if tests_failed > 0:
        parent._print_error(f"‚ö†Ô∏è  {tests_failed} non-critical tests failed")
      else:
        parent._print_success("All completion tests passed!")

    def diagnose(self, include_env: bool = True, include_completion: bool = True) -> None:
      """
      Comprehensive diagnostic analysis for development issues.

      :param include_env: Include environment variable analysis
      :param include_completion: Include completion system analysis
      """
      parent = self.parent
      parent._print_info("üîç Running comprehensive diagnostic analysis...")

      if include_env:
        parent._print_info("=== Environment Variable Analysis ===")
        print(f"Current shell: {os.environ.get('SHELL', 'Unknown')}")
        print(f"Current PID: {os.getpid()}")
        print()

        # Check project-related environment variables
        project_vars = {k: v for k, v in os.environ.items() if parent.project_name.lower() in k.lower() or 'comp_' in k.lower()}
        if project_vars:
          print(f"{parent.project_name.capitalize()} completion environment variables:")
          for k, v in project_vars.items():
            print(f"  {k}={v}")
        else:
          print(f"No {parent.project_name.capitalize()} completion environment variables found")
        print()

      if include_completion:
        parent._print_info("=== Completion System Analysis ===")

        # Test completion system availability
        try:
          result = subprocess.run("python examples/cls_example completion --help",
                                shell=True, capture_output=True, text=True, timeout=5)
          if result.returncode == 0:
            parent._print_success("Completion system is available")
          else:
            parent._print_error("Completion system unavailable or broken")
        except Exception as e:
          parent._print_error(f"Failed to test completion system: {e}")

        # Test shell-specific completion
        shell = os.environ.get('SHELL', '')
        if 'bash' in shell:
          parent._run_command(f"complete -p | grep -i {parent.project_name} || echo 'No bash completion found'", "Bash completion status:")
        elif 'zsh' in shell:
          parent._run_command(f"compdef | grep -i {parent.project_name} || echo 'No zsh completion found'", "Zsh completion status:")

        print()

      # Python environment check
      parent._print_info("=== Python Environment ===")
      parent._run_command("poetry run python --version", "Python version:")
      parent._run_command(f"poetry run python -c 'import {parent.project_name}; print(f\"{parent.project_name.capitalize()} module: {{{parent.project_name}.__file__}}\")'", f"{parent.project_name.capitalize()} module location:")

      # Project structure check
      parent._print_info("=== Project Structure ===")
      important_files = [
        "pyproject.toml",
        f"{parent.project_name}/__init__.py",
        "examples/cls_example",
        "examples/multi_class_example"
      ]

      for file_path in important_files:
        full_path = parent.project_root / file_path
        if full_path.exists():
          parent._print_success(f"‚úÖ {file_path} exists")
        else:
          parent._print_error(f"‚ùå {file_path} missing")

      parent._print_success("Diagnostic analysis complete!")



if __name__ == '__main__':
  # Create the CLI instance and store reference for inner classes
  dev_tools = FreyjaDevTools()
  sys.modules[__name__].__dict__['_parent_instance'] = dev_tools

  cli = FreyjaCLI(FreyjaDevTools, title=f"{dev_tools.project_name.capitalize()} Development Tools")
  result = cli.run()
  sys.exit(result if isinstance(result, int) else 0)
